<!doctype html>
<html>
<head>
<style>
html {
  background-color: #ffffff;
}
body {
  background-color: #ffffff;
  margin: 0;
  padding: 0;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
  font-family: Helvetica;
}
#header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 30px;
  background-color: #eeeeee;
  border-bottom: 1px solid #cccccc;
  padding: 3px;
}
#cur_color {
  height: 28px;
  width: 36px;
  border: 1px solid #666666;
}
#header .fa {
  position: absolute; font-size: 25px; color: #ccc; top: 6px;
}
#header #coords {
  position: absolute; font-size: 25px; color: #ccc; top: 4px; right: 80px;
}
#header .fa:hover {
  color: #999;
  cursor: pointer;
}
#header #load {
  left: 6px;
}
#header #save {
  left: 45px;
}
#header #fullscreen {
  right: 6px;
}
#header #restart {
  right: 40px;
}

#sidebar {
  position: absolute;
  z-index: 100;
  top: 37px;
  bottom: 0;
  width: 250px;
  background-color: #eee;
  color: #666;
  padding: 10px;
}
#sidebar td {
  vertical-align: top
}
#sidebar h3 {
  margin: 10px 0;
}
#sidebar table {
  width: 100%;
}
#sidebar input {
  width: 98%;
}
#sidebar textarea {
  width: 98%;
  height: 80px;
}
#sidebar input[type=text], #sidebar textarea {
  border: 1px solid #dddddd
}
#sidebar #obj_types {
  width: 130px;
}
#sidebar #props_panel {
  position: absolute;
  top: 0;
  bottom: 50%;
  left: 0;
  right: 0;
  padding: 10px;
}
#sidebar #sprites_panel {
  position: absolute;
  top: 50%;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 10px;
}
#sidebar .panel {
  overflow: auto;
}
#sidebar .link {
  cursor: pointer;
  text-decoration: underline;
}
#sidebar .link:hover {
  color: blue;
}
#sidebar .link.small {
  font-size: 11px;
  vertical-align: middle;
  text-decoration: none;
}
#sidebar .link.small:hover {
  text-decoration: underline;
}
canvas {
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
</style>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
<canvas id="canvas">
</canvas>
<div id="sidebar" style="right: 0px">
  <div id="props_panel" class="panel">
    <h3 id="properties_heading"></h3>
    <table id="properties">
      <tr id="id_properties">
        <td><label for="obj_id">ID:</label></td>
        <td><input id="obj_id" type="text"></td>
      </tr>
      <tr id="types_properties">
        <td><label for="obj_types">Types:</label></td>
        <td>
          <div id="obj_types"></div>
          <button id="add_type">Add Type</button>
          <select id="add_types" style="display: none"></select> <button id="new_type" style="display: none">New</button> <button id="cancel_add_type" style="display: none">Cancel</button>
        </td>
      </tr>
      <tr id="tile_properties">
        <td><label for="is-solid">Solid:</label></td>
        <td><input type="checkbox" id="is-solid"></td>
      </tr>
      <tr class="event_properties">
        <td><label for="event">Code:</label></td>
        <td><select id="event"></select></td>
      </tr>
      <tr class="event_properties">
        <td colspan="2"><textarea id="code"></textarea></td>
      </tr>
    </table>
    <!--button id="edit-img">Edit Image</button><br-->
  </div>

  <div id="sprites_panel" class="panel">
    <h3>Spritesheets</h3>
    <label for="add-img">Add Spritesheet:</label>
    <input type="file" id="add-img"><br><br>
    <select id="tilesets" style="display: none"></select><br><br>
    <canvas id="tileset" width="200" height="100"></canvas><br><br>
    <label id="update-img-label" for="update-img" style="display: none">Replace Spritesheet Image:</label>
    <input type="file" id="update-img" style="display: none">
  </div>
</div>
<div id="header">
  <div id="load" class="fa fa-folder-open-o"></div><div id="save" class="fa fa-floppy-o"></div><div id="coords"></div>
  <!--div id="cur_color"></div--><div id="restart" class="fa fa-play-circle-o"></div><div id="fullscreen" class="fa fa-arrows-alt"></div>
</div>
<script>
var MAX_VEL = 50;

var grid_width = 100;
var grid_height = 100;
var tile_size = 16;
var num_tiles_w = 0;
var num_tiles_h = 0;
var selected_tile = null;
var selected_obj = null;
var curr_sprite = null;
var img_editor = null;
var start_x = 0;
var start_y = 0;
var imgs = [];
var img_ix = null;
var zoom = 2;
var levels = [{objects: [], type: 'level'}];
var level = null;
var level_num;
var types = {};

var player = {x: 0, y: 0, vel_x: 0, vel_y: 0, accel_y: 0};
loadLevel(1);
var events = {
  level: ['Start'],
  type: ['Create', 'Collide']
};
select(level);

function Viewport(width, height) {
  this.width = width;
  this.height = height;
  this.transform_x = 0;
  this.transform_y = 0;
}

Viewport.prototype.follow = function(pos) {
  var perct_x = (pos.x - this.transform_x) / this.width;
  var perct_y = (pos.y - this.transform_y) / this.height;

  if (perct_x > .8) {
    var dest_x = Math.round(this.width * .8);
    this.transform_x = pos.x - dest_x;
  }
  else if (perct_x < .2) {
    var dest_x = Math.round(this.width * .2);
    this.transform_x = pos.x - dest_x; 
  }
  if (perct_y > .8) {
    var dest_y = Math.round(this.height * .8);
    this.transform_y = pos.y - dest_y;
  }
  else if (perct_y < .2) {
    var dest_y = Math.round(this.height * .2);
    this.transform_y = pos.y - dest_y;
  }
  this.updateTransform();
};

Viewport.prototype.updateTransform = function() {
  ctx.imageSmoothingEnabled = false;
  ctx.mozImageSmoothingEnabled = false;
  ctx.webkitImageSmoothingEnabled = false;
  ctx.msImageSmoothingEnabled = false;
  ctx.setTransform(zoom, 0, 0, zoom, -this.transform_x, -this.transform_y);
};

document.body.style.overflow = 'hidden';

var canvas = $('canvas');
var ctx = canvas.getContext('2d');

var viewport = new Viewport(0, 0);
setupViewport();
window.addEventListener('resize', setupViewport);

function setupViewport() {
  viewport.width = Math.ceil(window.innerWidth / zoom);
  viewport.height = Math.ceil(window.innerHeight / zoom);
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;

  // whenever we mess with the canvas width/height, we need to reset the transform
  viewport.updateTransform();
}

$('load').addEventListener('click', function() {
  load();
});

$('save').addEventListener('click', function() {
  save();
});

$('restart').addEventListener('click', function() {
  restart();
});

$('fullscreen').addEventListener('click', function() {
  var body = document.body;
  var reqFullscreen = body.requestFullscreen || body.webkitRequestFullscreen || body.mozRequestFullScreen || body.msRequestFullscreen;
  var exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
  if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
    exitFullscreen && exitFullscreen.apply(document);
  else
    reqFullscreen && reqFullscreen.apply(body);
});

function GameEditor(ctx) {
  this.onMouseMove = this.onMouseMove.bind(this);
  this.onMouseDown = this.onMouseDown.bind(this);
  this.onKeyPress = this.onKeyPress.bind(this);
  canvas.addEventListener('mousemove', this.onMouseMove);
  canvas.addEventListener('mousedown', this.onMouseDown);
  document.addEventListener('keypress', this.onKeyPress);
}

GameEditor.prototype.onMouseDown = function(evt) {
  var pt = {
    x: Math.floor((evt.pageX + viewport.transform_x) / zoom),
    y: Math.floor((evt.pageY + viewport.transform_y) / zoom)
  };

  var obj_under_mouse;
  for (var i = 0; i < objects.length; i++) {
    var obj = objects[i];
    if (intersectsPoint(obj, pt))
      obj_under_mouse = obj;
  }

  if (obj_under_mouse) {
    if (obj_under_mouse == selected_tile) {
      deselect();
    }
    else {
      if (curr_sprite != null) {
        obj_under_mouse.img_ix = img_ix;
        obj_under_mouse.sprite_x = curr_sprite.x;
        obj_under_mouse.sprite_y = curr_sprite.y;
        obj_under_mouse.types = curr_sprite.types.slice(); // deep clone
      }
      select(obj_under_mouse);
    }
  }
  else {
    var obj = createTile(pxToGrid(pt.x), pxToGrid(pt.y), curr_sprite.x, curr_sprite.y, img_ix, curr_sprite.types);
    select(obj);
  }
};

var LEFT_BTN = 1;
GameEditor.prototype.onMouseMove = function(evt) {
  var pt_x = Math.floor((evt.pageX + viewport.transform_x) / zoom);
  var pt_y = Math.floor((evt.pageY + viewport.transform_y) / zoom);
  var grid_x = pxToGrid(pt_x);
  var grid_y = pxToGrid(pt_y);
  
  var coords = grid_x + ', ' + grid_y;
  if ($('coords').innerText != coords)
    $('coords').innerText = coords;

  if (evt.buttons % 2 != LEFT_BTN)
    return;
  if (curr_sprite == null)
    return;
  if (document.activeElement && (document.activeElement.tagName == 'TEXTAREA' || document.activeElement.tagName == 'INPUT'))
    return;

  var pt = {x: pt_x, y: pt_y};
  var obj_under_mouse;
  for (var i = 0; i < objects.length; i++) {
    var obj = objects[i];
    if (intersectsPoint(obj, pt))
      obj_under_mouse = obj;
  }
  
  if (!obj_under_mouse) {
    var obj = createTile(grid_x, grid_y, curr_sprite.x, curr_sprite.y, img_ix, curr_sprite.types);
    select(obj);
  }
  else {
    obj_under_mouse.img_ix = img_ix;
    obj_under_mouse.sprite_x = curr_sprite.x;
    obj_under_mouse.sprite_y = curr_sprite.y;
    obj_under_mouse.types = curr_sprite.types.slice(); // deep clone
  }
};

// load & save
GameEditor.prototype.onKeyPress = function(evt) {
  if (document.activeElement && document.activeElement == $('code'))
    return;
  
  if (evt.keyCode == ' '.charCodeAt(0))
    jump();
};

GameEditor.prototype.destroy = function() {
  canvas.removeEventListener('mousedown', this.onMouseDown);
  canvas.removeEventListener('mousemove', this.onMouseMove);
  document.removeEventListener('keypress', this.onKeyPress);
};

// i thought these colors were taken from a DB16 palette
// but they weren't, they're from another "DawnBringer" palette here:
// http://pixeljoint.com/forum/forum_posts.asp?TID=22582
// var colors = [
//   null, // at present 1-9 are the colors, 0 means no-block & isn't a color
//   '#5e6660', // dark-ish grey
//   '#5d4632', // dark brown
//   '#44508c', // med (darker) blue
//   '#a6414d', // dark red
//   '#c86b36', // orange
//   '#52903c', // dark green
//   '#db7ebd', // pink
//   '#deac85', // tan
//   '#f2de70' // yellow
// ];

var game_editor = new GameEditor(ctx);

function select(obj) {
  if (!obj)
    throw new Error('select() called with no object');

  // this runs before blur, save before updateProperties() blows the code away
  if (document.activeElement.tagName == 'TEXTAREA')
    saveCode();

  selected_obj = obj;
  selected_tile = obj.type == 'tile' ? obj : null;
  updateProperties();
  renderTileset();
}

function deselect() {
  select(level);
}

function updateProperties() {
  if (selected_tile) {
    $('properties_heading').innerText = 'Object Properties';
  }
  else if (selected_obj && selected_obj.type == 'sprite') {
    $('properties_heading').innerText = 'Sprite Properties';
  }
  else if (selected_obj && selected_obj.type == 'type') {
    $('properties_heading').innerText = `${selected_obj.name} Properties`;
  }
  else if (selected_obj && selected_obj.type == 'level') {
    $('properties_heading').innerText = 'Level Properties';
  }
  else {
    if (!selected_obj)
      throw new Error('No selected object');
    else
      throw new Error(`Unknown selected object type: ${selected_obj.type}`);
  }

  if (selected_obj.type == 'type') {
    hide('id_properties');
  }
  else {
    $('obj_id').value = selected_obj.id || '';
    show('id_properties');
  }

  if (selected_obj.type == 'sprite' || selected_obj.type == 'tile') {
    var type_html = selected_obj.types.map(name => `<div>
      <span class="nav_to_type link" data-type="${name}">${name}</span> <span class="remove_type link small" data-type="${name}">remove</span>
    </div>`);
    
    var types_div = $('obj_types');
    types_div.innerHTML = type_html.join('');
    for (var nav_link of types_div.querySelectorAll('.nav_to_type')) {
      nav_link.addEventListener('click', function(evt) {
        var type_name = evt.target.getAttribute('data-type');
        select(types[type_name]);
      });
    }
    for (var remove_link of types_div.querySelectorAll('.remove_type')) {
      remove_link.addEventListener('click', function(evt) {
        var type_name = evt.target.getAttribute('data-type');
        var type_ix = selected_obj.types.indexOf(type_name);
        if (type_ix == -1)
          throw new Error(`Remove type clicked but type ${type_name} not found in ${selected_obj.types}`);
        selected_obj.types.splice(type_ix, 1);
        updateProperties();

        if (selected_obj.type == 'sprite') {
          cascade(selected_obj, function(obj) {
            var type_ix = obj.types.indexOf(type_name);
            if (type_ix > -1)
              obj.types.splice(type_ix, 1);
          });
        }
      });
    }

    var type_opts = [['Select:', 'CHOOSE_TYPE']];
    type_opts = type_opts.concat(Object.keys(types).map(name => [name, name]));
    setSelectOptions($('add_types'), type_opts);

    show('types_properties');
  }
  else {
    hide('types_properties');
  }

  for (var el of $$('event_properties')) {
    if (selected_obj.type == 'type' || selected_obj.type == 'level') {
      var evts = events[selected_obj.type];
      var opts = evts.map(name => [`On ${name}`, name.toLowerCase()]);
      setSelectOptions($('event'), opts);

      var evt_handler_name = 'on_' + $('event').value;
      var evt_handler = selected_obj[evt_handler_name];
      if (typeof(evt_handler) == 'function')
        evt_handler = getAsyncFnBody(evt_handler, evt_handler_name);
      $('code').value = evt_handler || '';

      show(el);
    }
    else
      hide(el);
  }

  if (selected_obj.type == 'tile') {
    $('is-solid').checked = selected_obj.is_solid;
    show('tile_properties');
  }
  else {
    hide('tile_properties');
  }
  
  // $('edit-img').textContent = 'Edit Image ' + /*obj.type*/;
}

function setSelectOptions(sel, options) {
  // remove old options
  while (sel.options.length)
    sel.removeChild(sel.options[0]);

  // add new options
  for (var option of options) {
    var opt = document.createElement('option');
    opt.appendChild(document.createTextNode(option[0]));
    opt.value = option[1];
    sel.appendChild(opt); 
  }
}

requestAnimationFrame(draw);
function draw() {
  // temporarily remove transforms in order to clear the right rect
  ctx.save();
  
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.restore();
  
  if (img_editor) {
    img_editor.draw();
  }
  else {
    update();

    // draw blocks on the grid
    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];
      if (imgs[obj.img_ix])
        ctx.drawImage(imgs[obj.img_ix], obj.sprite_x * tile_size, obj.sprite_y * tile_size, tile_size, tile_size, obj.x, obj.y, tile_size, tile_size);
    }

    // draw selection
    if (selected_tile) {
      ctx.strokeStyle = '#3B88FD';
      ctx.lineWidth = 2;
      ctx.strokeRect(selected_tile.x, selected_tile.y, selected_tile.w, selected_tile.h);
    }

    // draw player
    // ctx.beginPath();
    // var radius = tile_size / 2;
    // ctx.arc(Math.floor(player.x) + radius, Math.floor(player.y) + radius, radius, 0, 2 * Math.PI, false);
    // ctx.fillStyle = '#5b99f4';
    // ctx.fill();
  }
  requestAnimationFrame(draw);
}

function update() {
  // friction/drag
  if (player.vel_x > 0)
    player.vel_x -= 0.1;
  else if (player.vel_y < 0)
    player.vel_x += 0.1;
  if (player.vel_y > 0)
    player.vel_y -= 0.1;
  else if (player.vel_y < 0)
    player.vel_y += 0.1;

  // y-axis acceleration (gravity) & x-axis acceleration (sideways gravity)
  if (player.accel_y)
    player.vel_y += player.accel_y;
  if (player.accel_x)
    player.vel_x += player.accel_x;

  // TODO: use a clamp() function
  if (player.vel_x > MAX_VEL)
    player.vel_x = MAX_VEL;
  else if (player.vel_x < -MAX_VEL)
    player.vel_x = -MAX_VEL;
  if (player.vel_y > MAX_VEL)
    player.vel_y = MAX_VEL;
  else if (player.vel_y < -MAX_VEL)
    player.vel_y = -MAX_VEL;

  player.x = player.x + player.vel_x;
  player.y = player.y + player.vel_y;

  // super-simple AABB collision detection & "slide" resolution
  // TODO: switch to the algorithm outlined in:
  // http://higherorderfun.com/blog/2012/05/20/the-guide-to-implementing-2d-platformers/
  for (var i = 0; i < objects.length; i++) {
    var obj = objects[i];
    var intersection = getIntersection(
      {x1: player.x, x2: player.x + tile_size, y1: player.y, y2: player.y + tile_size},
      {x1: obj.x, x2: obj.x + obj.w, y1: obj.y, y2: obj.y + obj.h}
    );
    if (intersection) {
      if (obj.is_solid) {
        var x_overlap = intersection.x2 - intersection.x1;
        var y_overlap = intersection.y2 - intersection.y1;
        if (x_overlap < y_overlap) {
          // back out the x overlap
          var player_on_left = player.x < obj.x;
          if (player_on_left)
            player.x -= x_overlap;
          else
            player.x += x_overlap;
          player.vel_x = 0;
        }
        else {
          // back out the y overlap
          var player_above = player.y < obj.y;
          if (player_above)
            player.y -= y_overlap;
          else
            player.y += y_overlap;

          // drop the y velocity to zero on a vertical collision
          // w/out this, the constant collisions caused by gravity
          // cause some side-effects
          // but sometimes it's not perfect, like when hitting a corner
          // dropping the `vel_x` to zero makes the sideways velocity drop to zero sometimes
          // when dropping to the ground
          player.vel_y = 0;
        }
      }
      fireEvent(obj, 'collide');
    }
  }

  if (player.vel_x || player.vel_y)
    viewport.follow(player);
}  

function intersectsPoint(rect, pt) {
  return rect.x <= pt.x && rect.x + rect.w > pt.x &&
    rect.y <= pt.y && rect.y + rect.h > pt.y;
}

function getIntersection(rect1, rect2) {
  if (rect1.x1 > rect1.x2 || rect1.y1 > rect1.y2)
    throw new Error('rect1 is degenerate');
  if (rect2.x1 > rect2.x2 || rect2.y1 > rect2.y2)
    throw new Error('rect2 is degenerate');

  var x1 = Math.max(rect1.x1, rect2.x1); // biggest left edge
  var x2 = Math.min(rect1.x2, rect2.x2); // smallest right edge

  var y1 = Math.max(rect1.y1, rect2.y1); // lowest top edge
  var y2 = Math.min(rect1.y2, rect2.y2); // highest bottom edge

  if (x1 >= x2 // if the biggest left edge is bigger than the smallest right edge
    || y1 >= y2) // or the lowest top edge is lower than the highest bottom edge
    return null; // then they don't actually intersect
  
  return {x1: x1, y1: y1, x2: x2, y2: y2};
}

function pxToGrid(px) {
  return Math.floor(px / tile_size);
}

$('code').addEventListener('blur', onBlur);
$('code').addEventListener('change', onBlur);
function onBlur(evt) {
  saveCode();
}

$('obj_id').addEventListener('blur', onTextInputChange);
$('obj_id').addEventListener('change', onTextInputChange);

$('add_type').addEventListener('click', function() {
  showAddTypeUI();
});

$('add_types').addEventListener('change', function(evt) {
  addType(evt.target.value);
  hideAddTypeUI();
});

$('new_type').addEventListener('click', function() {
  var type_name = prompt("Enter name of new type:");
  if (!type_name)
    return;

  if (type_name in types)
    return alert('There is already a type of this name.');

  types[type_name] = {type: 'type', name: type_name};
  addType(type_name);
  updateProperties();
  hideAddTypeUI();
});

function addType(type_name) {
  if (selected_obj.types.includes(type_name))
    return;

  selected_obj.types.push(type_name);
  updateProperties();

  // cascade the type addition to all objects using this sprite
  if (selected_obj.type == 'sprite') {
    cascade(selected_obj, function(obj) {
      if (!obj.types.includes(type_name))
        obj.types.push(type_name)
    });
  }
}

// cascade changes to all objects that use a sprite
function cascade(sprite, cb) {
  for (var obj of objects)
    if (obj.sprite_x == sprite.x && obj.sprite_y == sprite.y)
      cb(obj);
}

$('cancel_add_type').addEventListener('click', function() {
  hideAddTypeUI();
});

function showAddTypeUI() {
  hide('add_type');
  show('add_types', 'new_type', 'cancel_add_type');
}

function hideAddTypeUI() {
  hide('add_types', 'new_type', 'cancel_add_type');
  show('add_type');
}

function saveCode() {
  var evt_name = $('event').value;
  if (!evt_name)
    throw new Error('saveCode() called when the event selector was not populated');

  selected_obj['on_' + evt_name] = $('code').value;
}

function onTextInputChange(evt) {
  var prop = evt.target.id.replace('obj_', '');
  var val = evt.target.value;
  if (prop == 'types')
    val = val.split(',').map(str => str.trim());

  if (selected_obj)
    selected_obj[prop] = val;
  else
    throw new Error('text input change called without a selected object');
}

$('is-solid').addEventListener('change', function(evt) {
  if (selected_tile)
    selected_tile.is_solid = !!evt.target.checked;
});

// $('edit-img').addEventListener('click', function() {
//   if (selected_tile)
//     edit(/*selected_tile.type*/);
// });

$('tilesets').addEventListener('change', function(evt) {
  viewSpritesheet(parseInt(evt.target.value));
  renderTileset();
});

$('tileset').addEventListener('click', function(evt) {
  if (!imgs.length)
    return;

  // if we make the tileset map scrollable, we may need to use pageX
  var x = evt.clientX - getClientLeft(evt.target);
  var y = evt.clientY - getClientTop(evt.target);
  var curr_sprite_x = pxToGrid(x);
  var curr_sprite_y = pxToGrid(y);

  // toggle selection on click of sprite
  if (selected_obj.type == 'sprite' && selected_obj.x == curr_sprite_x && selected_obj.y == curr_sprite_y) {
    curr_sprite = null;
    return deselect();
  }
  
  var sprite = getSprite(curr_sprite_x, curr_sprite_y);
  if (!sprite) {
    sprite = {type: 'sprite', id: '', x: curr_sprite_x, y: curr_sprite_y, types: []};
    setSprite(sprite);
  }
  curr_sprite = sprite;
  select(sprite);
});

function getSprite(sprite_x, sprite_y) {
  var sprite_coords = `${sprite_x},${sprite_y}`;
  var sprites = imgs[img_ix].sprites;
  return sprites[sprite_coords];
}

function setSprite(sprite) {
  var sprite_coords = `${sprite.x},${sprite.y}`;
  var sprites = imgs[img_ix].sprites;
  sprites[sprite_coords] = sprite;
}

function viewSpritesheet(ix) {
  img_ix = ix;
}

function getClientLeft(el) {
  var offset = 0;

  while (el) {
    offset += parseInt(el.offsetLeft);
    el = el.offsetParent;         
  }
  return offset;
}

function getClientTop(el) {
  var offset = 0;

  while (el) {
    offset += parseInt(el.offsetTop);
    el = el.offsetParent;         
  }
  return offset;
}

$('add-img').addEventListener('change', function() {
  var file = this.files[0];
  var data_url = URL.createObjectURL(file);
  var img_ix = imgs.length;
  loadImage(img_ix, data_url, file.name);
});

$("update-img").addEventListener("change", function() {
  var file = this.files[0];
  var data_url = URL.createObjectURL(file);
  var img_ix = parseInt($('tilesets').value);
  loadImage(img_ix, data_url, file.name);
});

async function loadImage(img_ix, data_url, filename, sprites) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.filename = filename;
    img.sprites = sprites || {};
    
    img.onload = function() {
      // free the memory (unfortunately this is a blob-url ref, not a full data-url)
      URL.revokeObjectURL(this.src);

      var prev_length = imgs.length;
      imgs[img_ix] = img;
      if (imgs.length > prev_length)
        viewSpritesheet(img_ix);

      // TODO: add an opt-out checkbox in case users are adding lots of images?
      // Or, instead, allow different grid sizes on each spritesheet via num_cols/num_rows text boxes
      var misaligned_dimensions = [];
      if (img.width % tile_size)
        misaligned_dimensions.push(`width (${img.width})`);
      if (img.height % tile_size)
        misaligned_dimensions.push(`height (${img.height})`)
      if (misaligned_dimensions.length)
        alert(`Warning: tileset image ${misaligned_dimensions.join(', ')} does not align with tile size (${tile_size})`);

      num_tiles_w = Math.ceil(img.width / tile_size);
      num_tiles_h = Math.ceil(img.height / tile_size);
      $('tileset').setAttribute('width', img.width);
      $('tileset').setAttribute('height', img.height);
      renderTileset();

      var opts = imgs.map((img, ix) => [img.filename, ix]);
      setSelectOptions($('tilesets'), opts);
      $('tilesets').value = img_ix;

      $("tilesets").style.display = '';
      $("update-img-label").style.display = '';
      $("update-img").style.display = '';
      $("tileset").style.display = '';
      resolve();
    };

    img.src = data_url;
  });
}

function renderTileset() {
  if (!(imgs[img_ix] instanceof HTMLImageElement))
    return;

  var canvas = $('tileset');
  var tileset_ctx = canvas.getContext('2d');
  tileset_ctx.clearRect(0, 0, canvas.width, canvas.height);
  tileset_ctx.imageSmoothingEnabled = false;
  tileset_ctx.drawImage(imgs[img_ix], 0, 0);

  // outline currently selected tile in tileset
  if (curr_sprite) {
    if (curr_sprite == selected_obj)
      tileset_ctx.strokeStyle = '#3B88FD'; // selected styling
    else
      tileset_ctx.strokeStyle = '#FFFFFF'; // white "current" styling

    tileset_ctx.lineWidth = 2;
    tileset_ctx.strokeRect(curr_sprite.x * tile_size, curr_sprite.y * tile_size, tile_size, tile_size);
  }
}

var LEFT = 37;
var UP = 38;
var RIGHT = 39;
var DOWN = 40;
var DEL = 8;
var ESC = 27;
document.addEventListener('keydown', function(evt) {
  if (document.activeElement && (document.activeElement.tagName == 'TEXTAREA' || document.activeElement.tagName == 'INPUT'))
    return;

  if (evt.keyCode == LEFT && player.accel_y != 0)
      player.vel_x = -5;
  else if (evt.keyCode == RIGHT && player.accel_y != 0)
      player.vel_x = 5;
  else if (evt.keyCode == UP && player.accel_x != 0)
    player.vel_y = -5;
  else if (evt.keyCode == DOWN && player.accel_x != 0)
    player.vel_y = 5;
  else if (evt.keyCode == DEL && selected_tile) {
    var ix = objects.indexOf(selected_tile);
    if (ix > -1)
      objects.splice(ix, 1);
    deselect();
  }
  else if (evt.keyCode == ESC) {
    if (img_editor) {
      img_editor.destroy();
      img_editor = null;
      game_editor = new GameEditor(ctx);
      viewport.follow(player);
    }
    else if (selected_obj) {
      deselect();
    }
  }
});

// function edit(img_ix) {
//   if (!img_editor) {
//     deselect();
//     img_editor = new ImageEditor(ctx, img_ix);
//     game_editor.destroy();
//   }
// }

function save() {
  var name = prompt('What would you like to name this game?');
  var data = {images: [], levels: levels, types: types};

  // serialize functions back to strings manually
  // otherwise they get wrapped in 'async function() { ... }'
  for (var level of levels) {
    serializeEvtHandlers(level);

    for (var obj of level.objects)
      serializeEvtHandlers(obj);
  }
  
  // serialize image pixel data
  for (var i = 0; i < imgs.length; i++) {
    if (imgs[i]) {
      var canvas = document.createElement('canvas');
      canvas.width = imgs[i].width;
      canvas.height = imgs[i].height;
      var context = canvas.getContext('2d');
      context.drawImage(imgs[i], 0, 0);
      data.images[i] = {url: canvas.toDataURL(), filename: imgs[i].filename, sprites: imgs[i].sprites};
    }
    else {
      data.images[i] = null;
    }
  }
  localStorage.setItem(name, JSON.stringify(data));
}

function serializeEvtHandlers(obj) {
  for (var prop in obj)
    if (prop.startsWith('on_') && typeof(obj[prop]) == 'function')
      obj[prop] = getAsyncFnBody(obj[prop], prop);
}

function getAsyncFnBody(fn, name) {
  var fn_str = fn.toString();
  var fn_body = fn_str.match(/async function[^{]+\{([\s\S]*)\}$/)[1];
  if (fn_body.length == fn_str.length)
    throw new Error(`getAsyncFnBody() unable to extract body of function ${name}`);

  return fn_body.trim();
}

function load() {
  var name = prompt('What game would you like to load?');
  loadGame(name);
}

function jump() {
  if (player.accel_y > 0)
    player.vel_y = -20;
  else if (player.accel_y < 0)
    player.vel_y = 20;
  if (player.accel_x > 0)
    player.vel_x = -20;
  else if (player.accel_x < 0)
    player.vel_x = 20;
}

// HTML DOM helpers
function toggle_visibility(id_or_el, id2, id3) {
  for (var id_or_el of Array.from(arguments)) {
    if (is_visible(id_or_el))
      hide(id_or_el);
    else
      show(id_or_el);
  }
}
function show(id_or_el, id2, id3) {
  for (var id_or_el of Array.from(arguments))
    $(id_or_el).style.display = '';  
}
function hide(id_or_el, id2, id3) {
  for (var id_or_el of Array.from(arguments))
    $(id_or_el).style.display = 'none';
}
function is_visible(id_or_el) {
  return $(id_or_el).style.display != 'none';
}
function $(id_or_el) {
  if (id_or_el instanceof HTMLElement)
    return id_or_el;
  else
    return document.getElementById(id_or_el);
}
function $$(class_name) {
  return document.getElementsByClassName(class_name);
}

function hasClass(el, class_name) {
  var class_names = el.className.split(' ');
  return class_names.indexOf(class_name) > -1;
}

function addClass(el, class_name) {
  var class_names = el.className.split(' ');
  if (class_names.indexOf(class_name) > -1)
    return;

  class_names.push(class_name);
  el.className = class_names.join(' ');
}

function removeClass(el, class_name) {
  var class_names = el.className.split(' ');
  var ix = class_names.indexOf(class_name);
  if (ix == -1)
    return;

  class_names.splice(ix, 1);
  el.className = class_names.join(' ');
}

/*function ImageEditor(ctx, img_ix) {
  this.color_ix = 0;
  this.img_ix = img_ix;
  this.px_size = 15;
  this.y = 50;
  this.x = 5;
  this.is_drawing = false;
  this.is_erasing = false;
  if (!imgs[img_ix]) {
    imgs[img_ix] = ctx.createImageData(tile_size, tile_size);

    // pre-fill new images to all-white
    var data = imgs[img_ix].data;
    for (var i = 0; i < data.length; i++)
      data[i] = 255;
  }
  this.img_data = imgs[img_ix];
  this.ctx = ctx;

  // reset the transform from the game's viewport
  this.ctx.setTransform(zoom, 0, 0, zoom, 0, 0);

  this.updateColorIndicator();

  this.onKeyPress = this.onKeyPress.bind(this);
  this.onMouseDown = this.onMouseDown.bind(this);
  this.onMouseMove = this.onMouseMove.bind(this);
  document.addEventListener('keypress', this.onKeyPress);
  document.addEventListener('mousemove', this.onMouseMove);
  document.addEventListener('mousedown', this.onMouseDown);
};

// official DawnBringer16 palette
ImageEditor.rgb = [
  [20, 12, 28], // #140C1C Black
  [68, 36, 52], // #442434 Dark Red
  [48, 52, 109], // #30346D Dark Blue
  [78, 74, 78], // #4E4A4F Dark Gray
  [133, 76, 48], // #854C30 Brown
  [52, 101, 36], // #346524 Dark Green
  [208, 70, 72], // #D04648 Red
  [117, 113, 97], // #757161 Light Gray
  [89, 125, 206], // #597DCE Light Blue
  [210, 125, 44], // #D27D2C Orange
  [133, 149, 161], // #8595A1 Blue/Gray
  [109, 170, 44], // #6DAA2C Light Green
  [210, 170, 153], // #D2AA99 Peach
  [109, 194, 202], // #6DC2CA Cyan
  [218, 212, 94], // #DAD45E Yellow
  [222, 238, 214] // #DEEED6 White
];

ImageEditor.prototype.onMouseDown = function(evt) {
  var x = Math.floor((evt.pageX - this.x) / this.px_size);
  var y = Math.floor((evt.pageY - this.y) / this.px_size);

  // user clicked outside the image size
  if (x < 0 || x >= tile_size || y < 0 || y >= tile_size)
    return;

  if (this.isPixel(x, y, this.color_ix)) {
    this.is_erasing = true;
    this.is_drawing = false;
  }
  else {
    this.is_erasing = false;
    this.is_drawing = true;
  }

  if (this.is_erasing)
    this.clearPixel(x, y);
  else if (this.is_drawing)
    this.setPixel(x, y, this.color_ix);
};

ImageEditor.prototype.onMouseMove = function(evt) {
  if (evt.buttons %2 != LEFT_BTN)
    return;

  var x = Math.floor((evt.pageX - this.x) / this.px_size);
  var y = Math.floor((evt.pageY - this.y) / this.px_size);

  // user is dragging outside the image size
  if (x < 0 || x >= tile_size || y < 0 || y >= tile_size)
    return;

  if (this.is_erasing)
    this.clearPixel(x, y);
  else if (this.is_drawing)
    this.setPixel(x, y, this.color_ix);
};

ImageEditor.prototype.setPixel = function(x, y, color_ix) {
  var ix = this.coordsToIx(this.img_data.width, x, y);
  var rgb = ImageEditor.rgb[color_ix];
  var data = this.img_data.data;
  data[ix] = rgb[0];
  data[ix+1] = rgb[1];
  data[ix+2] = rgb[2];
  data[ix+3] = 255; // alpha channel
};

ImageEditor.prototype.isPixel = function(x, y, color_ix) {
  var ix = this.coordsToIx(this.img_data.width, x, y);
  var data = this.img_data.data;
  var rgb = ImageEditor.rgb[color_ix];
  return data[ix] == rgb[0] || data[ix+1] == rgb[1] || data[ix+2] == rgb[2]
};

ImageEditor.prototype.clearPixel = function(x, y) {
  var ix = this.coordsToIx(this.img_data.width, x, y);
  var data = this.img_data.data;
  data[ix] = 255;
  data[ix+1] = 255;
  data[ix+2] = 255;
  data[ix+3] = 255; // alpha channel
};

ImageEditor.prototype.onKeyPress = function(evt) {
  if (evt.keyCode == '0'.charCodeAt(0))
    this.setColor(0);
  else if (evt.keyCode == '1'.charCodeAt(0))
    this.setColor(1);
  else if (evt.keyCode == '2'.charCodeAt(0))
    this.setColor(2);
  else if (evt.keyCode == '3'.charCodeAt(0))
    this.setColor(3);
  else if (evt.keyCode == '4'.charCodeAt(0))
    this.setColor(4);
  else if (evt.keyCode == '5'.charCodeAt(0))
    this.setColor(5);
  else if (evt.keyCode == '6'.charCodeAt(0))
    this.setColor(6);
  else if (evt.keyCode == '7'.charCodeAt(0))
    this.setColor(7);
  else if (evt.keyCode == '8'.charCodeAt(0))
    this.setColor(8);
  else if (evt.keyCode == '9'.charCodeAt(0))
    this.setColor(9);
  else if (evt.keyCode == 'f'.charCodeAt(0))
    this.fill(this.color_ix);
};

ImageEditor.prototype.setColor = function(color_ix) {
  this.color_ix = color_ix;
  this.updateColorIndicator();
};

ImageEditor.prototype.updateColorIndicator = function() {
  var rgb = ImageEditor.rgb[this.color_ix];
  $('cur_color').style.backgroundColor = 'rgb(' + rgb[0] + ', ' + rgb[1] + ', ' + rgb[2] + ')';
};

ImageEditor.prototype.fill = function(color_ix) {
  for (var x = 0; x < tile_size; x++)
    for (var y = 0; y < tile_size; y++)
      this.setPixel(x, y, color_ix);
};

ImageEditor.prototype.draw = function() {
  var img_w = this.img_data.width;
  var data = this.img_data.data;
  for (var i = 0; i < data.length; i = i + 4) {
    this.ctx.fillStyle = 'rgb(' + data[i] + ', ' + data[i+1] + ', ' + data[i+2] + ')';
    var coords = this.ixToCoords(img_w, i);
    this.ctx.fillRect(coords.x * this.px_size + this.x, coords.y * this.px_size + this.y, this.px_size, this.px_size);
  }

  this.ctx.strokeStyle = '#000000';
  this.ctx.lineWidth = 1;
  this.ctx.strokeRect(1 + this.x, 1 + this.y, this.px_size * tile_size, this.px_size * tile_size);
  this.ctx.lineWidth = 0;
};

ImageEditor.prototype.ixToCoords = function(img_w, i) {
  i = i / 4;
  x = i % img_w;
  y = (i - x) / img_w;
  return {x: x, y: y};
};

ImageEditor.prototype.coordsToIx = function(img_w, x, y) {
  return (x + y * img_w) * 4;
};

ImageEditor.prototype.destroy = function() {
  document.removeEventListener('keypress', this.onKeyPress);
  document.removeEventListener('mousedown', this.onMouseDown);
  document.removeEventListener('mousemove', this.onMouseMove);
};*/



// public API functions (available to the game designer)

function setGravity(x, y) {
  if (x != null)
    player.accel_x = x;
  if (y != null)
    player.accel_y = y;
}

function setSpeed(x, y) {
  if (x != null)
    player.vel_x = x;
  if (y != null)
    player.vel_y = y;
}

function setPosition(x, y) {
  if (x != null)
    player.x = x * tile_size;
  if (y != null)
    player.y = y * tile_size;
}

function setStart(x, y) {
  if (x != null)
    start_x = x * tile_size;
  if (y != null)
    start_y = y * tile_size;
}

async function loadGame(game_name) {
  var json = localStorage.getItem(game_name);
  if (!json)
    return alert('Sorry, no level with the name "' + game_name + '" exists.');
  var parsed = JSON.parse(json);
  levels = parsed.levels;
  types = parsed.types || {};

  var images = parsed.images || [];
  for (var i = 0; i < 10; i++) {
    if (images[i])
      await loadImage(i, images[i].url, images[i].filename, images[i].sprites);
    else
      imgs[i] = null;
  }

  loadLevel(1);
}

function restart() {
  loadLevel(level_num);
}

function loadLevel(level_n) {
  level_num = level_n;
  level = levels[level_num - 1];
  objects = level.objects;

  player.x = start_x;
  player.y = start_y;
  player.vel_y = 0;
  player.vel_x = 0;
  player.accel_x = 0;
  player.accel_y = 0;

  fireEvent(level, 'start');
  for (var obj of objects)
    fireEvent(obj, 'create');
}

function createTile(grid_x, grid_y, sprite_x, sprite_y, spritesheet_ix, types) {
  if (spritesheet_ix == null)
    spritesheet_ix = 0;

  if (!types) {
    var sprite = getSprite(sprite_x, sprite_y);
    if (sprite && sprite.types)
      types = sprite.types;
    else
      types = [];
  }

  x = grid_x * tile_size;
  y = grid_y * tile_size;
  var obj = {
    x: x,
    y: y,
    w: tile_size,
    h: tile_size,
    sprite_x: sprite_x,
    sprite_y: sprite_y,
    img_ix: spritesheet_ix,
    is_solid: true,
    type: 'tile',
    types: types
  };

  objects.push(obj);
  fireEvent(obj, 'create');
  return obj;
}

function cloneTile(tile, overrides) {
  var new_tile = {};
  for (var prop in tile) {
    var val = tile[prop];
    if (prop in overrides)
      val = overrides[prop];

    if (Array.isArray(val))
      new_tile[prop] = val.slice();
    else
      new_tile[prop] = val;
  }

  // if types are explicit and sprite_x/y are
  // then types should be derived from the new sprite_x/y
  if (!('types' in overrides) && ('sprite_x' in overrides || 'sprite_y' in overrides)) {
    var sprite = getSprite(new_tile.sprite_x, new_tile.sprite_y);
    new_tile.types = (sprite && sprite.types) || [];
  }

  objects.push(new_tile);
  fireEvent(new_tile, 'create');
  return new_tile;
}

function getTile(grid_x, grid_y) {
  var x = grid_x * tile_size;
  var y = grid_y * tile_size;
  return objects.find(obj => obj.x == x && obj.y == y);
}

function getGridX(obj) {
  return Math.floor(obj.x / tile_size);
}
function setGridX(obj, grid_x) {
  obj.x = grid_x * tile_size;
}

function getGridY(obj) {
  return Math.floor(obj.y / tile_size);
}
function setGridY(obj, grid_y) {
  obj.y = grid_y * tile_size;
}

async function animate(obj, steps, seconds_per_step) {
  for (var step = 0; step < steps; step++) {
    await timeout(seconds_per_step);
    obj.sprite_x++;
  }
}

const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
function fireEvent(obj, evt_name, this_obj) {
  if (obj.type == 'tile') {
    for (var type_name of obj.types) {
      var type = types[type_name];
      if (type)
        fireEvent(type, evt_name, obj);
    }
    return;
  }
  else if (obj.type == 'level') {
    this_obj = obj;
  }
  else if (obj.type == 'type') {
    // pass through; these are called recursively from tile.types
  }
  else {
    throw new Error(`Unexpected object passed to fireEvent, type ${obj.type}`);
  }

  var handler_name = 'on_' + evt_name;
  if (!obj[handler_name])
    return;

  try {
    if (typeof(obj[handler_name]) != 'function')
      obj[handler_name] = new AsyncFunction(obj[handler_name]);

    obj[handler_name].call(this_obj);
  }
  catch(err) {
    alert(err.message);

    // comment out the code that just failed
    var lines = obj[handler_name].split('\n');
    for (var i = 0; i < lines.length; i++)
      lines[i] = '// ' + lines[i];

    obj[handler_name] = lines.join('\n');

    if (selected_obj == this_obj)
      updateProperties();
  }
}

async function timeout(seconds) {
  return new Promise(function(resolve, reject) {
    setTimeout(resolve, seconds * 1000);
  });
}

</script>
</body>
</html>