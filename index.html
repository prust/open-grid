<!doctype html>
<html>
<head>
<style>
body { margin: 0; padding: 0; }
#header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 30px;
  background-color: #eeeeee;
  border-bottom: 1px solid #cccccc;
  padding: 3px;
}
#cur_color {
  height: 28px;
  width: 36px;
  border: 1px solid #666666;
}

#properties {
  position: absolute;
  z-index: 100;
  right: 0;
  bottom: 0;
  width: 400px;
  height: 200px;
  background-color: #eee;
  color: #666;
  padding: 5px;
}
ul {
  margin: 0;
}
textarea {
  width: 390px;
  height: 150px;
}
</style>
</head>
<body>
<canvas id="canvas">
</canvas>
<div id="properties">
  API:
  <ul>
    <li>setGravity(x, y)</li>
    <li>setSpeed(x, y)</li>
  </ul>
<textarea id="code"></textarea>
</div>
<div id="header">
  <div id="cur_color"></div>
</div>
<script>
document.body.style.overflow = 'hidden';
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
canvas.setAttribute('width', window.innerWidth || document.body.clientWidth);
canvas.setAttribute('height', window.innerHeight || document.body.clientHeight);

var MAX_VEL = 20;

var grid_width = 100;
var grid_height = 100;
var grid = [];
var code = [];
var block_size = 40;
var selected_block = null;
var current_color_ix = 1;
colors = [
  null, // at present 1-9 are the colors, 0 means no-block & isn't a color
  '#5e6660',
  '#5d4632',
  '#44508c',
  '#a6414d',
  '#c86b36',
  '#52903c',
  '#db7ebd',
  '#deac85',
  '#f2de70'
];
setColor(1);

var player = {x: 0, y: 0, vel_x: 0, vel_y: 0, accel_y: 1};

// initialize grid with 0 objects
for (var x = 0; x < grid_width; x++) {
  grid[x] = [];
  code[x] = [];

  for (var y = 0; y < grid_height; y++)
    grid[x][y] = 0;
}

canvas.addEventListener('mouseup', function(evt) {
  var pos = posFromEvt(evt);
  if (!grid[pos.x][pos.y])
    grid[pos.x][pos.y] = current_color_ix;
  else
    selectBlock(pos.x, pos.y);
});

function setColor(color_ix) {
  current_color_ix = color_ix;
  document.getElementById('cur_color').style.backgroundColor = colors[color_ix];
}

function selectBlock(x, y) {
  selected_block = {x: x, y: y};
  updateCode(x, y);
}

function updateCode(x, y) {
  document.getElementById('code').value = code[x][y] || '';
}

function posFromEvt(evt) {
  var pos = {x: evt.pageX, y: evt.pageY};
  return toBlockCoords(pos);
}

function toBlockCoords(pos) {
  return {x: Math.floor(pos.x / block_size), y: Math.floor(pos.y / block_size)};
}

requestAnimationFrame(draw);
function draw() {
  ctx.clearRect(0, 0, grid_width * block_size, grid_height * block_size);
  
  update();

  // draw blocks on the grid
  for (var x = 0; x < grid_width; x++) {
    for (var y = 0; y < grid_height; y++) {
      if (grid[x][y]) {
        ctx.fillStyle = colors[grid[x][y]];

        ctx.fillRect(x * block_size, y * block_size, block_size, block_size);
      }
    }
  }

  // draw selection
  if (selected_block) {
    ctx.strokeStyle = '#6666FF';
    ctx.lineWidth=5;
    ctx.strokeRect(selected_block.x * block_size, selected_block.y * block_size, block_size, block_size);
  }

  // draw player
  ctx.beginPath();
  var radius = block_size / 2;
  ctx.arc(Math.floor(player.x) + radius, Math.floor(player.y) + radius, radius, 0, 2 * Math.PI, false);
  ctx.fillStyle = '#000099';
  ctx.fill();
  requestAnimationFrame(draw);
}

function update() {
  // friction/drag
  if (player.vel_x > 0)
    player.vel_x -= 0.1;
  else if (player.vel_y < 0)
    player.vel_x += 0.1;
  if (player.vel_y > 0)
    player.vel_y -= 0.1;
  else if (player.vel_y < 0)
    player.vel_y += 0.1;

  // y-axis acceleration (gravity) & x-axis acceleration (sideways gravity)
  if (player.accel_y)
    player.vel_y += player.accel_y;
  if (player.accel_x)
    player.vel_x += player.accel_x;

  // TODO: use a clamp() function
  if (player.vel_x > MAX_VEL)
    player.vel_x = MAX_VEL;
  else if (player.vel_x < -MAX_VEL)
    player.vel_x = -MAX_VEL;
  if (player.vel_y > MAX_VEL)
    player.vel_y = MAX_VEL;
  else if (player.vel_y < -MAX_VEL)
    player.vel_y = -MAX_VEL;

  player.x = player.x + player.vel_x;
  player.y = player.y + player.vel_y;

  // super-simple AABB collision detection & "slide" resolution
  for (var x = 0; x < grid_width; x++) {
    for (var y = 0; y < grid_height; y++) {
      if (grid[x][y]) {
        var intersection = getIntersection(
          {x1: player.x, x2: player.x + block_size, y1: player.y, y2: player.y + block_size},
          {x1: x * block_size, x2: (x + 1) * block_size, y1: y * block_size, y2: (y + 1) * block_size}
        );

        if (intersection) {
          var x_overlap = intersection.x2 - intersection.x1;
          var y_overlap = intersection.y2 - intersection.y1;
          if (x_overlap < y_overlap) {
            // back out the x overlap
            var player_on_left = player.x < x * block_size;
            if (player_on_left)
              player.x -= x_overlap;
            else
              player.x += x_overlap;
            player.vel_x = 0;
          }
          else {
            // back out the y overlap
            var player_above = player.y < y * block_size;
            if (player_above)
              player.y -= y_overlap;
            else
              player.y += y_overlap;

            // drop the y velocity to zero on a vertical collision
            // w/out this, the constant collisions caused by gravity
            // cause some side-effects
            // but sometimes it's not perfect, like when hitting a corner
            // dropping the `vel_x` to zero makes the sideways velocity drop to zero sometimes
            // when dropping to the ground
            player.vel_y = 0;
          }
          onCollide(x, y);
        }
      }
    }
  }
}

function onCollide(x, y) {
  if (code[x][y]) {
    try {
      eval(code[x][y]);
    }
    catch(err) {
      alert(err.message);
      var lines = code[x][y].split('\n');
      for (var i = 0; i < lines.length; i++)
        lines[i] = '// ' + lines[i];

      code[x][y] = lines.join('\n');
      if (selected_block && selected_block.x == x && selected_block.y == y)
        updateCode(x, y);
    }
  }
}

function getIntersection(rect1, rect2) {
  if (rect1.x1 > rect1.x2 || rect1.y1 > rect1.y2)
    throw new Error('rect1 is degenerate');
  if (rect2.x1 > rect2.x2 || rect2.y1 > rect2.y2)
    throw new Error('rect2 is degenerate');

  var x1 = Math.max(rect1.x1, rect2.x1); // biggest left edge
  var x2 = Math.min(rect1.x2, rect2.x2); // smallest right edge

  var y1 = Math.max(rect1.y1, rect2.y1); // lowest top edge
  var y2 = Math.min(rect1.y2, rect2.y2); // highest bottom edge

  if (x1 >= x2 // if the biggest left edge is bigger than the smallest right edge
    || y1 >= y2) // or the lowest top edge is lower than the highest bottom edge
    return null; // then they don't actually intersect
  
  return {x1: x1, y1: y1, x2: x2, y2: y2};
}

// load & save
document.addEventListener('keypress', function(evt) {
  if (document.activeElement && document.activeElement == document.getElementById('code'))
    return;
  
  if (evt.keyCode == 's'.charCodeAt(0))
    save();
  else if (evt.keyCode == 'l'.charCodeAt(0))
    load();
  else if (evt.keyCode == ' '.charCodeAt(0))
    jump();
  else if (evt.keyCode == '1'.charCodeAt(0))
    setColor(1);
  else if (evt.keyCode == '2'.charCodeAt(0))
    setColor(2);
  else if (evt.keyCode == '3'.charCodeAt(0))
    setColor(3);
  else if (evt.keyCode == '4'.charCodeAt(0))
    setColor(4);
  else if (evt.keyCode == '5'.charCodeAt(0))
    setColor(5);
  else if (evt.keyCode == '6'.charCodeAt(0))
    setColor(6);
  else if (evt.keyCode == '7'.charCodeAt(0))
    setColor(7);
  else if (evt.keyCode == '8'.charCodeAt(0))
    setColor(8);
  else if (evt.keyCode == '9'.charCodeAt(0))
    setColor(9);
});

document.addEventListener('focusout', function(evt) {
  if (evt.target.getAttribute('id') == 'code' && selected_block)
    code[selected_block.x][selected_block.y] = evt.target.value;
});

var LEFT = 37;
var UP = 38;
var RIGHT = 39;
var DOWN = 40;
var DEL = 8;
document.addEventListener('keydown', function(evt) {
  if (document.activeElement && document.activeElement == document.getElementById('code'))
    return;

  if (evt.keyCode == LEFT && player.accel_y != 0)
      player.vel_x = -5;
  else if (evt.keyCode == RIGHT && player.accel_y != 0)
      player.vel_x = 5;
  else if (evt.keyCode == UP && player.accel_x != 0)
    player.vel_y = -5;
  else if (evt.keyCode == DOWN && player.accel_x != 0)
    player.vel_y = 5;
  else if (evt.keyCode == DEL && selected_block) {
    grid[selected_block.x][selected_block.y] = 0;
    selected_block = null;
  }
});

function save() {
  var name = prompt('What would you like to name this level?');
  localStorage.setItem(name, JSON.stringify({grid: grid, code: code}));
}

function load() {
  var name = prompt('What level would you like to load?');
  var json = localStorage.getItem(name);
  if (!json)
    return alert('Sorry, no level with that name exists.');
  var parsed = JSON.parse(json);
  grid = parsed.grid;
  code = parsed.code;

  player = {x: 0, y: 0, vel_x: 0, vel_y: 0, accel_y: 1};
}

function jump() {
  if (player.accel_y > 0)
    player.vel_y = -MAX_VEL;
  else if (player.accel_y < 0)
    player.vel_y = MAX_VEL;
  if (player.accel_x > 0)
    player.vel_x = -MAX_VEL;
  else if (player.accel_x < 0)
    player.vel_x = MAX_VEL;
}

// public API functions (available to the game designer)
function setGravity(x, y) {
  if (x != null)
    player.accel_x = x;
  if (y != null)
  player.accel_y = y;
}

function setSpeed(x, y) {
  if (x != null)
    player.vel_x = x;
  if (y != null)
    player.vel_y = y;
}

</script>
</body>
</html>