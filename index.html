<!doctype html>
<html>
<head>
<style>
html {
  background-color: #ffffff;
}
body {
  background-color: #ffffff;
  margin: 0;
  padding: 0;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
  font-family: Helvetica;
}
#header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 30px;
  background-color: #eeeeee;
  border-bottom: 1px solid #cccccc;
  padding: 3px;
}
#cur_color {
  height: 28px;
  width: 36px;
  border: 1px solid #666666;
}
#header {
  color: #ccc;
  font-size: 25px;
}
#header #coords {
  position: absolute; top: 4px; right: 80px;
}
#header .fa:hover {
  color: #999;
  cursor: pointer;
}
#header #load {
  left: 6px;
  margin-left: 6px;
  margin-right: 6px;
}
#header #save {
  left: 45px;
  margin-left: 6px;
  margin-right: 6px;
}
#header #status {
  color: #999;
  margin-left: 6px;
  margin-right: 6px;
}
#header #fullscreen {
  position: absolute; right: 6px; top: 6px;
}
#header #restart {
  position: absolute; right: 40px; top: 6px;
}

#sidebar {
  position: absolute;
  z-index: 100;
  top: 37px;
  bottom: 0;
  width: 250px;
  background-color: #eee;
  color: #666;
  padding: 10px;
}
#sidebar td {
  vertical-align: top;
  white-space: nowrap;
}
#sidebar h3 {
  margin: 10px 0;
}
#sidebar table {
  width: 100%;
}
#sidebar input {
  width: 98%;
}
#sidebar input[type=text] {
  border: 1px solid #dddddd
}
#sidebar input::placeholder {
  color: #dddddd
}
#sidebar #obj_id {
  width: 150px;
}
#sidebar #props_panel {
  position: absolute;
  top: 0;
  bottom: 60%;
  left: 0;
  right: 0;
  padding: 10px;
}
#sidebar #sprites_panel {
  position: absolute;
  top: 40%;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 10px;
}
#sidebar .panel {
  overflow: auto;
}
#sidebar .component_name {
  color: #ccc;
  text-transform: uppercase;
  font-size: 12px;
}
#sidebar .link {
  cursor: pointer;
  font-size: 11px;
  vertical-align: middle;
  text-decoration: none;
  text-transform: lowercase;
}
#sidebar .link:hover {
  color: blue;
  text-decoration: underline;
}
canvas {
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
</style>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
<canvas id="canvas">
</canvas>
<div id="sidebar" style="right: 0px">
  <div id="props_panel" class="panel">
    Level: <select id="levels"></select> <button id="new_level">New Level</button>
    <h3 id="properties_heading"></h3>

    <div id="sprite_properties"><label for="obj_id">Sprite ID:</label> <input id="obj_id" type="text"><br><br></div>

    <div id="components_properties">
      <table id="components_details"></table>
      <button id="add_component">Add Component</button>
      <select id="add_components" style="display: none"></select> <button id="cancel_add_component" style="display: none">Cancel</button>
    </div>
  </div>

  <div id="sprites_panel" class="panel">
    Layer: <select id="layers"></select> <button id="toggle_layer"></button> <button id="new_layer">New Layer</button><br>
    <button id="layer_up">Move Up</button> <button id="layer_down">Move Down</button> <button id="delete_layer">Delete Layer</button>

    <h3>Spritesheets</h3>
    <label for="add-img">Add Spritesheet:</label>
    <input type="file" id="add-img"><br><br>
    <select id="tilesets" style="display: none"></select><br><br>
    <canvas id="tileset" width="200" height="100"></canvas><br><br>
    <label id="update-img-label" for="update-img" style="display: none">Replace Spritesheet Image:</label>
    <input type="file" id="update-img" style="display: none">
  </div>
</div>
<div id="header">
  <div id="load" class="fa fa-folder-open-o"></div>
  <div id="save" class="fa fa-floppy-o"></div>
  <div id="export" class="fa fa-download"></div>
  <span id="status"></span>
  <div id="coords"></div>
  <!--div id="cur_color"></div-->
  <div id="restart" class="fa fa-play-circle"></div>
  <div id="fullscreen" class="fa fa-arrows-alt"></div>
</div>
<script>
var MAX_VEL = 50;

var grid_width = 100;
var grid_height = 100;
var tile_size = 16;
var num_tiles_w = 0;
var num_tiles_h = 0;
var selected_obj = null;
var tileset_sel = null;
var tileset_hover = null;
var img_editor = null;
var start_x = 0;
var start_y = 0;
var imgs = [];
var img_ix = null;
var zoom = 2;
var levels = [{objects: [], layers: [{id: 1, order: 0, visible: true}]}];
var level = null;
var layer = null;
var level_num;
var dir = {left: {x: -1, y: 0}, right: {x: 1, y: 0}, up: {x: 0, y: -1}, down: {x: 0, y: 1}};

// similar to how time can be presented in "units" of ms/sec/min/hr
// distance can be presented in "units" of pixels or tiles
// the component (or sprite?) could define a default_unit
// if the decimal is not a clean tenths (i.e. "0.5", "0.1"), it could auto-bump to a smaller unit

// indexes in the component property arrays
const NAME = 0, ID = 1, TYPE = 2, DEFAULT = 3, VISIBLE = 4;
var required_comp_ids = ['Positionable', 'Drawable'];
var components = {
  Positionable: [
    ['Left', 'x', 'int', 0],
    ['Top', 'y', 'int', 16],
    ['Width', 'w', 'int', tile_size],
    ['Height', 'h', 'int', tile_size]
  ],
  Drawable: [
    ['Sprite X', 'sprite_x', 'int', 0],
    ['Sprite Y', 'sprite_y', 'int', 0],
    ['Spritesheet #', 'img_ix', 'int', 0],
    ['Layer ID', 'layer_id', 'int', 0]
  ],
  Speed: [
    ['Right', 'vel_x', 'int', 0],
    ['Down', 'vel_y', 'int', 0]
  ],
  Collideable: [
    ['Left Padding', 'padding_left', 'int', 0],
    ['Right Padding', 'padding_right', 'int', 0],
    ['Top Padding', 'padding_top', 'int', 0],
    ['Bottom Padding', 'padding_bottom', 'int', 0]
  ],
  Animateable: [
    ['Number of Frames', 'frame_count', 'int', 1],
    ['Current Frame', 'curr_frame', 'int', 0, false],
    ['Animate Interval', 'anim_interval', 'int', 1000], // TODO: "time" type w/ ms/sec/min/hr dropdown UI
    ['Last Animated', 'anim_timestamp', 'int', 0, false]
  ],
  Rotateable: [
    ['Rotates to Sprite IDs', 'rot_to_sprite_ids', 'array:string', []] // TODO: make this a plus icon that expands to multiple rows
  ],
  Growable: [
    ['Grow Interval', 'grow_interval', 'int', 1000], // TODO: make this a "time" type with ms/sec/min/hr dropdown UI
    ['Grow Direction', 'grow_dir', 'string', 'left'], // TODO: make this a drop-down with options
    ['Last Grown Time', 'grow_timestamp', 'int', 0, false],
    ['Grow Sprite ID', 'grow_sprite_id', 'string', '']
  ],
  Shoots: [
    ['Bullet Sprite ID', 'bullet_sprite_id', 'string', ''],
    ['Shoot Interval', 'shoot_interval', 'int', 1000],
    ['Last Shoot Time', 'shoot_timestamp', 'int', 0, false]
  ],
  Bullet: [
    ['Damage Points', 'damage_pts', 'int', 50]
  ],
  Damageable: [
    ['Health Points', 'health_pts', 'int', 100],
    // ['Damage Animation', 'damage_anim', 'int', null],
    ['Death Animation', 'death_anim_id', 'int', null],
    ['Death Anim # Frames', 'death_anim_frame_count', 'int', null],
    ['Death Anim Interval', 'death_anim_interval', 'int', null]
  ],
  Buyer: [
    ['Cost', 'cost', 'int', 1],
    ['Item Sprite ID', 'item_sprite_id', 'str', '']
  ],
  'Has Money': [
    ['Money', 'money', 'int', 0],
    ['Earns Amount', 'earns_amt', 'int', 0],
    ['Earns Interval', 'earns_interval', 'int', 5000],
    ['Last Earned Time', 'earned_timestamp', 'int', 0, false]
  ]
};

var game_name = '';
var is_playing = false;

var player = {x: 0, y: 0, w: tile_size, h: tile_size, vel_x: 0, vel_y: 0, accel_y: 0};
// events: 'Start', 'Create', 'Collide', 'Click', 'Mouse Enter', 'Mouse Leave', 'Out Of Bounds'
loadLevel(1);



function Viewport(width, height) {
  this.width = width;
  this.height = height;
  this.transform_x = 0;
  this.transform_y = 0;
}

Viewport.prototype.follow = function(pos) {
  var perct_x = (pos.x - this.transform_x) / this.width;
  var perct_y = (pos.y - this.transform_y) / this.height;

  if (perct_x > .8) {
    var dest_x = Math.round(this.width * .8);
    this.transform_x = pos.x - dest_x;
  }
  else if (perct_x < .2) {
    var dest_x = Math.round(this.width * .2);
    this.transform_x = pos.x - dest_x; 
  }
  if (perct_y > .8) {
    var dest_y = Math.round(this.height * .8);
    this.transform_y = pos.y - dest_y;
  }
  else if (perct_y < .2) {
    var dest_y = Math.round(this.height * .2);
    this.transform_y = pos.y - dest_y;
  }
  this.updateTransform();
};

Viewport.prototype.updateTransform = function() {
  ctx.imageSmoothingEnabled = false;
  ctx.mozImageSmoothingEnabled = false;
  ctx.webkitImageSmoothingEnabled = false;
  ctx.msImageSmoothingEnabled = false;
  ctx.setTransform(zoom, 0, 0, zoom, -this.transform_x, -this.transform_y);
};

document.body.style.overflow = 'hidden';

var canvas = $('canvas');
var ctx = canvas.getContext('2d');

var viewport = new Viewport(0, 0);
setupViewport();
window.addEventListener('resize', setupViewport);

function setupViewport() {
  viewport.width = Math.ceil(window.innerWidth / zoom);
  viewport.height = Math.ceil(window.innerHeight / zoom);
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;

  // whenever we mess with the canvas width/height, we need to reset the transform
  viewport.updateTransform();
}

$('load').addEventListener('click', function() {
  load();
});

$('save').addEventListener('click', function() {
  save();
});

$('export').addEventListener('click', function() {
  var json = serializeGame();
  downloadJSON(json, (game_name || 'game') + '.json');
});

$('restart').addEventListener('click', function() {
  var is_play_btn = hasClass($('restart'), 'fa-play-circle');
  toggleClass($('restart'), 'fa-play-circle', 'fa-stop-circle');

  if (is_play_btn) {
    save();
    play();
  }
  else {
    stop();
  }
});

$('fullscreen').addEventListener('click', function() {
  var body = document.body;
  var reqFullscreen = body.requestFullscreen || body.webkitRequestFullscreen || body.mozRequestFullScreen || body.msRequestFullscreen;
  var exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
  if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
    exitFullscreen && exitFullscreen.apply(document);
  else
    reqFullscreen && reqFullscreen.apply(body);
});



function GameEditor(ctx) {
  this.onMouseMove = this.onMouseMove.bind(this);
  this.onMouseDown = this.onMouseDown.bind(this);
  this.onKeyPress = this.onKeyPress.bind(this);
  canvas.addEventListener('mousemove', this.onMouseMove);
  canvas.addEventListener('mousedown', this.onMouseDown);
  document.addEventListener('keypress', this.onKeyPress);
}

GameEditor.prototype.onMouseDown = function(evt) {
  if (is_playing)
    return;

  var pt = {
    x: Math.floor((evt.pageX + viewport.transform_x) / zoom),
    y: Math.floor((evt.pageY + viewport.transform_y) / zoom)
  };

  var paint_mode = selected_obj && selected_obj.type == 'sprite';

  // find the object currently under the mouse pointer
  var obj_under_mouse;

  // paint-mode is locked to curr layer; gameplay & selection modes are constrained to visible layers
  var layers = paint_mode ? [layer] : level.layers.filter(l => l.visible);
  layers.reverse(); // the default (rendering) order is bottom to top; for selection we need top-to-bottom

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label
  outerloop:
  for (var l of layers) {
    for (var obj of objects) {
      if (obj.layer_id == l.id && intersectsPoint(obj, pt)) {
        obj_under_mouse = obj;
        break outerloop;
      }
    }
  }

  if (paint_mode) {
    if (obj_under_mouse)
      deleteObject(obj_under_mouse);
    createObject(pxToGrid(pt.x) * tile_size, pxToGrid(pt.y) * tile_size, selected_obj);
  }
  else {
    if (obj_under_mouse == selected_obj)
      deselect();
    else
      select(obj_under_mouse);
  }
};

var LEFT_BTN = 1;
GameEditor.prototype.onMouseMove = function(evt) {
  if (is_playing)
    return;

  var pt_x = Math.floor((evt.pageX + viewport.transform_x) / zoom);
  var pt_y = Math.floor((evt.pageY + viewport.transform_y) / zoom);
  var grid_x = pxToGrid(pt_x);
  var grid_y = pxToGrid(pt_y);
  
  var coords = grid_x + ', ' + grid_y;
  if ($('coords').innerText != coords)
    $('coords').innerText = coords;

  if (evt.buttons % 2 != LEFT_BTN)
    return;
  if (document.activeElement && (document.activeElement.tagName == 'TEXTAREA' || document.activeElement.tagName == 'INPUT'))
    return;
  
  var paint_mode = selected_obj && selected_obj.type == 'sprite';

  var pt = {x: pt_x, y: pt_y};
  var obj_under_mouse;
  for (var obj of objects)
    if (intersectsPoint(obj, pt))
      if (!paint_mode || obj.layer_id == layer.id)
        obj_under_mouse = obj;

  if (paint_mode) {
    if (obj_under_mouse)
      deleteObject(obj_under_mouse);

    createObject(grid_x * tile_size, grid_y * tile_size, selected_obj);
  }
};

// load & save
GameEditor.prototype.onKeyPress = function(evt) {
  if (document.activeElement && document.activeElement == $('code'))
    return;
  
  if (evt.keyCode == ' '.charCodeAt(0))
    jump();
};

GameEditor.prototype.destroy = function() {
  canvas.removeEventListener('mousedown', this.onMouseDown);
  canvas.removeEventListener('mousemove', this.onMouseMove);
  document.removeEventListener('keypress', this.onKeyPress);
};


var game_editor = new GameEditor(ctx);
game_name = getQueryVariable('game') || '';
if (game_name) {
  hideDesignUI();
  hide('restart');

  var filename = `${game_name}.json`;
  fetch(filename).then(function(res) {
    return res.json();
  }).then(async function(game_obj) {
    await loadGame(game_obj);
    
    if (getQueryVariable('import') == 'true') {
      // strip querystring after import, so future refreshes don't re-import
      window.history.replaceState({}, document.title, window.location.pathname);

      showDesignUI();
      show('restart');
    }
    else {
      play();
    }
  });
}

function select(obj) {
  // this runs before blur, save before updatePropertiesUI() blows the code away
  // TODO: This was previously done for code; do we need to do it for all text inputs?
//  if (document.activeElement.tagName == 'INPUT')
//    saveCode();

  selected_obj = obj;
  updatePropertiesUI();
  updateTilesetUI();
}

function deselect() {
  select(null);
}

function updateLevelsUI() {
  var opts = [];
  for (var i = 0; i < levels.length; ++i)
    opts.push([i + 1, i + 1]);
  setSelectOptions('levels', opts);
  $('levels').value = levels.indexOf(level) + 1;
}

function updatePropertiesUI() {
  if (selected_obj) {
    if (selected_obj.type != 'sprite')
      $('properties_heading').innerText = 'Object Properties';
    else if (selected_obj.type == 'sprite')
      $('properties_heading').innerText = 'Sprite Properties';
    else
      throw new Error(`Unknown selected object type: ${selected_obj.type}`);
  }

  if (selected_obj && selected_obj.type == 'sprite') {
    $('obj_id').value = selected_obj.id || '';
    show('sprite_properties');
  }
  else {
    hide('sprite_properties');
  }

  if (selected_obj) {
    var component_opts = [['Select:', 'CHOOSE_COMPONENT']];
    component_opts = component_opts.concat(Object.keys(components).map(name => [name, name]));
    setSelectOptions('add_components', component_opts);

    show('components_properties');

    let html = '';

    // always order them in the official component order
    for (var comp_id in components) {
      if (!hasComp(selected_obj, comp_id))
        continue;

      var removeable = required_comp_ids.indexOf(comp_id) == -1;
      html += `
        <tr><td colspan="2" class="component_name">${comp_id} <span class="remove_component link" data-component="${comp_id}" ${removeable ? '' : 'style="display: none"'}>(remove)</span></td></tr>`;

      for (var prop of components[comp_id]) {
        // skip invisible properties
        if (prop[VISIBLE] === false)
          continue;

        var val = selected_obj[prop[ID]];
        
        html += `
          <tr id="components_properties">
            <td><label for="${prop[ID]}">${prop[NAME]}</label></td>
            <td><input id="${prop[ID]}" value="${val == null ? '' : val}" placeholder="${prop[DEFAULT] || ''}"></td>
          </tr>`;
      }
    }
    $('components_details').innerHTML = html;
    show('components_details');

    for (var remove_link of $('components_details').querySelectorAll('.remove_component')) {
      remove_link.addEventListener('click', function(evt) {
        var component_name = evt.target.getAttribute('data-component');
        
        // these two are, at present, required
        if (required_comp_ids.indexOf(component_name) > -1)
          return;

        var component_ix = selected_obj.components.indexOf(component_name);
        if (component_ix == -1)
          throw new Error(`Remove Component clicked but component ${component_name} not found in ${selected_obj.components}`);
        selected_obj.components.splice(component_ix, 1);
        updatePropertiesUI();

        // if (selected_obj.type == 'sprite') {
        //   cascade(selected_obj, function(obj) {
        //     var component_ix = obj.components.indexOf(component_name);
        //     if (component_ix > -1)
        //       obj.components.splice(component_ix, 1);
        //   });
        // }
      });
    }

  }
  else {
    hide('components_properties');
    hide('components_details');
  }
}

function updateLayerUI() {
  var opts = level.layers.map(l => [l.id, l.id]);
  setSelectOptions('layers', opts);
  $('layers').value = layer.id;

  var layer_ix = level.layers.indexOf(layer);
  $('layer_up').disabled = layer_ix == level.layers.length - 1;
  $('layer_down').disabled = layer_ix == 0;
  $('delete_layer').disabled = level.layers.length == 1;
  $('toggle_layer').innerText = layer.visible ? 'Hide' : 'Show';
}

function updateTilesetUI() {
  if (!(imgs[img_ix] instanceof HTMLImageElement))
    return;

  var canvas = $('tileset');
  var tileset_ctx = canvas.getContext('2d');
  tileset_ctx.clearRect(0, 0, canvas.width, canvas.height);
  tileset_ctx.imageSmoothingEnabled = false;
  tileset_ctx.drawImage(imgs[img_ix], 0, 0);

  if (tileset_hover) {
    let sprite = tileset_hover;
    tileset_ctx.strokeStyle = '#99CCFF'; // selected styling
    tileset_ctx.lineWidth = 2;
    tileset_ctx.strokeRect(sprite.sprite_x * tile_size, sprite.sprite_y * tile_size, sprite.w, sprite.h);
  }

  var x, y, w, h;
  if (tileset_sel) {
    let sel = tileset_sel;
    x = sel.start_x < sel.end_x ? sel.start_x : sel.end_x;
    y = sel.start_y < sel.end_y ? sel.start_y : sel.end_y;
    w = Math.abs(sel.end_x - sel.start_x) + 1;
    h = Math.abs(sel.end_y - sel.start_y) + 1;
    tileset_ctx.strokeStyle = '#FF0000';
    tileset_ctx.lineWidth = 2;
    tileset_ctx.strokeRect(x * tile_size, y * tile_size, w * tile_size, h * tile_size);
  }
  else if (selected_obj && selected_obj.type == 'sprite') {
    // outline currently selected tile in tileset
    let obj = selected_obj;
    x = obj.sprite_x * tile_size;
    y = obj.sprite_y * tile_size;
    w = obj.w;
    h = obj.h;

    // display hit box so the game designer can visually see the hit area
    var has_hit_box = obj.padding_left || obj.padding_right || obj.padding_top || obj.padding_bottom;
    if (has_hit_box) {
      var hit_x = x + (obj.padding_left || 0);
      var hit_y = y + (obj.padding_top || 0);
      var hit_w = w - (obj.padding_left || 0) - (obj.padding_right || 0);
      var hit_h = h - (obj.padding_top || 0) - (obj.padding_bottom || 0);
    }

    // display hit box first, so it's underneath the selection box
    if (has_hit_box) {
      tileset_ctx.strokeStyle = '#FFFF00';
      tileset_ctx.lineWidth = 2;
      tileset_ctx.strokeRect(hit_x, hit_y, hit_w, hit_h);
    }
    
    // draw selection box 2nd, so it's on top
    tileset_ctx.strokeStyle = '#3B88FD'; // selected styling
    tileset_ctx.lineWidth = 2;
    tileset_ctx.strokeRect(x, y, w, h);
  }
}

function setSelectOptions(sel, options) {
  var sel = $(sel);

  // remove old options
  while (sel.options.length)
    sel.removeChild(sel.options[0]);

  // add new options
  for (var option of options) {
    var opt = document.createElement('option');
    opt.appendChild(document.createTextNode(option[0]));
    opt.value = option[1];
    sel.appendChild(opt); 
  }
}


// SYSTEMS:

// TODO:
// * RenderSystem (migrate from draw(); depends on Drawable, Positionable)
// * PhysicsSystem (migrate from update(); depends on Positionable, Speed, Collideable, emits 'collide' & 'out of bounds')

// uses Animateable
function AnimationSystem() {
}
AnimationSystem.prototype.update = function() {
  for (var obj of objects) {
    if (hasComp(obj, 'Animateable')) {
      var dest_frame_num = obj.curr_frame + 1;
      if (dest_frame_num < obj.frame_count && processInterval(obj, 'anim')) {
        obj.sprite_x++;
        obj.curr_frame = dest_frame_num;
      }
    }
  }
};

// uses Rotateable
// function AISystem() {
// }

// uses Growable
function GrowthSystem() {
}
GrowthSystem.prototype.update = function() {
  let objects_to_grow = [];
  for (let obj of objects)
    if (hasComp(obj, 'Growable'))
      if (processInterval(obj, 'grow'))
        objects_to_grow.push(obj);
  
  // do the createObject outside the objects loop, to avoid infinite recursion
  for (let obj of objects_to_grow) {
    // remove 'Growable' b/c each tile only grows once (the next tile does the next growth)
    obj.components.splice(obj.components.indexOf('Growable'), 1);

    let x = obj.x + dir[obj.grow_dir].x * tile_size;
    let y = obj.y + dir[obj.grow_dir].y * tile_size;

    let sprite = getSpriteByID(obj.grow_sprite_id);
    let grown_obj = createObject(x, y, sprite, obj.layer_id);
  }
}

function ShootSystem() {
}
ShootSystem.prototype.update = function() {
  for (var obj of objects) {
    if (hasComp(obj, 'Shoots')) {
      if (processInterval(obj, 'shoot')) {
        var sprite = getSpriteByID(obj.bullet_sprite_id);
        createObject(obj.x, obj.y, sprite);
      }
    }
  }
}

// uses Bullet & Damageable, subscribes to 'collide'
function HealthSystem() {
  canvas.addEventListener('collide', function(evt) {
    var bullet, damageable;
    if (hasComp(evt.obj, 'Bullet') && hasComp(evt.other, 'Damageable')) {
      bullet = evt.obj;
      damageable = evt.other;
    }
    else if (hasComp(evt.other, 'Bullet') && hasComp(evt.obj, 'Damageable')) {
      bullet = evt.other;
      damageable = evt.obj;
    }
    else {
      return;
    }

    damageable.health_pts -= bullet.damage_pts;
    if (damageable.health_pts <= 0)
      this.onDeath(damageable);
  });
}

HealthSystem.prototype.onDeath = function() {
  if (obj.death_anim_id) {
    if (!hasComp(obj, 'Animateable'))
      obj.components.push('Animateable');

    let sprite = getSpriteByID(obj.death_anim_id);
    obj.sprite_x = sprite.sprite_x;
    obj.sprite_y = sprite.sprite_y;
    obj.img_ix = sprite.img_ix;

    obj.curr_frame = 0;
    obj.frame_count = obj.death_anim_frame_count;
    obj.anim_interval = obj.death_anim_interval;
  }
}

HealthSystem.prototype.update = function() {
};

// uses Buyer & Has Money
function MoneyManagementSystem() {
  canvas.addEventListener('mousedown', function(evt) {
    if (!is_playing)
      return;

    var pt = {
      x: Math.floor((evt.pageX + viewport.transform_x) / zoom),
      y: Math.floor((evt.pageY + viewport.transform_y) / zoom)
    };

    for (var obj of objects) {
      if (hasComp(obj, 'Buyer') && hasComp(obj, 'Has Money')) {
        if (obj.money >= obj.cost) {
          obj.money -= obj.cost;

          // render the purchased item on the highest layer
          let layer_id;
          var highest_order = null;
          var highest_layer_id = null;
          for (var layer of level.layers) {
            if (highest_order == null || layer.order > highest_order) {
              highest_order = layer.order;
              highest_layer_id = layer.id;
            }
          }
          layer_id = highest_layer_id;

          // lookup sprite data
          let sprite = getSpriteByID(obj.item_sprite_id);
          
          createObject(pxToGrid(pt.x) * tile_size, pxToGrid(pt.y) * tile_size, sprite);
        }
      }
    }
  });
}

MoneyManagementSystem.prototype.update = function() {
  for (var obj of objects)
    if (hasComp(obj, 'Has Money') && obj.earns_amt)
      if (processInterval(obj, 'earns'))
        obj.money += obj.earns_amt;
};

var systems = [
  new AnimationSystem(),
  new GrowthSystem(),
  new ShootSystem(),
  new HealthSystem(),
  new MoneyManagementSystem()
];

function processInterval(obj, prefix) {
  if (!is_playing)
    return false;

  var curr_time = Date.now();
  var ts_prop = prefix + '_timestamp';
  obj[ts_prop] = obj[ts_prop] || Date.now();
  if (curr_time - obj[ts_prop] > obj[prefix + '_interval']) {
    obj[ts_prop] = curr_time;
    return true;
  }
  else {
    return false;
  }
}

function hasComp(obj, comp_id) {
  return obj.components.indexOf(comp_id) > -1;
}



requestAnimationFrame(draw);
function draw() {
  // temporarily remove transforms in order to clear the right rect
  ctx.save();
  
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.restore();
  
  if (img_editor) {
    img_editor.draw();
  }
  else {
    update();

    // draw blocks on each layer the grid

    for (var layer of level.layers) {
      if (!layer.visible)
        continue;

      for (var obj of objects) {
        if (obj.layer_id != layer.id)
          continue;
        if (!imgs[obj.img_ix])
          continue;

        if ('opacity' in obj)
          ctx.globalAlpha = obj.opacity;
        ctx.drawImage(imgs[obj.img_ix], obj.sprite_x * tile_size, obj.sprite_y * tile_size, obj.w, obj.h, obj.x, obj.y, obj.w, obj.h);
        if ('opacity' in obj)
          ctx.globalAlpha = 1;
      }
    }

    // draw selection
    if (selected_obj && selected_obj.type != 'sprite') {
      ctx.strokeStyle = '#3B88FD';
      ctx.lineWidth = 2;
      ctx.strokeRect(selected_obj.x, selected_obj.y, selected_obj.w, selected_obj.h);
    }
  }
  requestAnimationFrame(draw);
}

function update() {
  var level_rect = getRect(level);
  for (var obj of objects) {
    if (obj.vel_x)
      obj.x += obj.vel_x;
    if (obj.vel_y)
      obj.y += obj.vel_y;

    if (obj.vel_x || obj.vel_y) {
      var obj_rect = getRect(obj);

      // delete Bullets when they go outside the level bounds (performance enhancement)
      if (!getIntersection(level_rect, obj_rect)) {
        if (hasComp(obj, 'Bullet'))
          deleteObject(obj);
      }

      // detect collisions & emit collide events
      for (var obj2 of objects) {
        if (obj == obj2)
          continue;

        var collides = getIntersection(obj_rect, getRect(obj2));
        if (collides) {
          var evt = new Event('collide');
          evt.obj = obj;
          evt.other = obj2;
          canvas.dispatchEvent(evt);
        }
      }
    }
  }

  if (player.vel_x || player.vel_y)
    viewport.follow(player);

  if (is_playing)
    for (var system of systems)
      system.update();
}

function getRect(obj) {
  var rect = {x1: obj.x, x2: obj.x + obj.w, y1: obj.y, y2: obj.y + obj.h};
  if (obj.padding_left)
    rect.x1 += obj.padding_left;
  if (obj.padding_right)
    rect.x2 -= obj.padding_right;
  if (obj.padding_top)
    rect.y1 += obj.padding_top;
  if (obj.padding_bottom)
    rect.y2 -= obj.padding_bottom;
  return rect;
}

function intersectsPoint(obj, pt) {
  return obj.x <= pt.x && obj.x + obj.w > pt.x &&
    obj.y <= pt.y && obj.y + obj.h > pt.y;
}

function getIntersection(rect1, rect2) {
  if (rect1.x1 > rect1.x2 || rect1.y1 > rect1.y2)
    throw new Error('rect1 is degenerate');
  if (rect2.x1 > rect2.x2 || rect2.y1 > rect2.y2)
    throw new Error('rect2 is degenerate');

  var x1 = Math.max(rect1.x1, rect2.x1); // biggest left edge
  var x2 = Math.min(rect1.x2, rect2.x2); // smallest right edge

  var y1 = Math.max(rect1.y1, rect2.y1); // lowest top edge
  var y2 = Math.min(rect1.y2, rect2.y2); // highest bottom edge

  if (x1 >= x2 // if the biggest left edge is bigger than the smallest right edge
    || y1 >= y2) // or the lowest top edge is lower than the highest bottom edge
    return null; // then they don't actually intersect
  
  return {x1: x1, y1: y1, x2: x2, y2: y2};
}

function pxToGrid(px) {
  return Math.floor(px / tile_size);
}

$('levels').addEventListener('change', function(evt) {
  loadLevel(parseInt(evt.target.value));
});

$('new_level').addEventListener('click', function(evt) {
  levels.push({objects: [], layers: [{id: 1, order: 0, visible: true}]});
  loadLevel(levels.length);
});

// focusout is like blur, but it bubbles so we can capture on the parent
$('components_details').addEventListener('focusout', onPropertyUpdate);
$('components_details').addEventListener('change', onPropertyUpdate);

function onPropertyUpdate(evt) {
  let prop_id = evt.target.getAttribute('id');

  // loop to find meta
  let prop_meta;
  for (var comp_id in components) {
    let component = components[comp_id];
    for (let prop of component)
      if (prop[ID] == prop_id)
        prop_meta = prop;
  }
  
  if (!prop_meta)
    throw new Error(`unable to find property metadata for id="${prop_id}"`);

  let type = prop_meta[TYPE];  
  let val = evt.target.value;
  if (type.startsWith('array:')) {
    type = type.replace('array:', '');
    val = val.split(',').map(s => parseVal(s, type));
  }
  else {
    val = parseVal(val, type);
  }
  selected_obj[prop_meta[ID]] = val;

  // TODO: move this & ECS-ify it by making a tileset/sprite rendering system
  // depend on the component w/ padding & subscribe to padding changes
  if (prop_meta[ID].startsWith('padding_'))
    updateTilesetUI();
}

function parseVal(str, type) {
  str = str.trim();

  if (type == 'int')
    return str ? parseInt(str) : 0;
  else if (type == 'float')
    return str ? parseFloat(str) : 0;
  else if (type == 'string')
    return str;
  else
    throw new Error(`Unsupported component property type: "${type}"`);
}

$('obj_id').addEventListener('blur', onTextInputChange);
$('obj_id').addEventListener('change', onTextInputChange);

$('add_component').addEventListener('click', function() {
  showAddComponentUI();
});

$('add_components').addEventListener('change', function(evt) {
  addComponent(evt.target.value);
  hideAddComponentUI();
});

function addComponent(component_name) {
  if (!selected_obj)
    throw new Error('addComponent called w/ no selected_obj');
  if (hasComp(selected_obj, component_name))
    return;

  selected_obj.components.push(component_name);
  updatePropertiesUI();

  // cascade the type addition to all objects using this sprite
  // QUESTION: should we cascade the default values if there aren't any on the objects?
  //   That'd be nice, but it'd be far more valuable to cascade the values the user sets...
  //   but how do we know the values on the obj weren't intentional overrides?!

  // if (selected_obj.type == 'sprite') {
  //   cascade(selected_obj, function(obj) {
  //     if (!hasComp(obj, component_name))
  //       obj.components.push(component_name)
  //   });
  // }
}

// cascade changes to all objects that use a sprite
// function cascade(sprite, cb) {
//   for (var obj of objects)
//     if (obj.sprite_x == sprite.sprite_x && obj.sprite_y == sprite.sprite_y && obj.img_ix == sprite.img_ix)
//       cb(obj);
// }

$('cancel_add_component').addEventListener('click', function() {
  hideAddComponentUI();
});

function showAddComponentUI() {
  hide('add_component');
  show('add_components', 'cancel_add_component');
}

function hideAddComponentUI() {
  hide('add_components', 'cancel_add_component');
  show('add_component');
}

function onTextInputChange(evt) {
  var prop = evt.target.id.replace('obj_', '');
  var val = evt.target.value;

  if (selected_obj)
    selected_obj[prop] = val;
  else
    throw new Error('text input change called without a selected object');
}

$('layers').addEventListener('change', function(evt) {
  layer = level.layers.find(l => l.id == evt.target.value);
  updateLayerUI();
});

$('new_layer').addEventListener('click', function() {
  var new_order = level.layers[level.layers.length - 1].order + 1;
  var max_id = null;
  for (var l of level.layers) {
    if (max_id == null || l.id > max_id)
      max_id = l.id;
  }

  var new_layer = {id: max_id + 1, order: new_order, visible: true};
  level.layers.push(new_layer);
  sortLayers();

  layer = new_layer;
  updateLayerUI();
});

$('layer_up').addEventListener('click', function() {
  var ix = level.layers.indexOf(layer);
  var layer_above = level.layers[ix + 1];
  if (!layer_above)
    throw new Error('layer up enabled, but no layer above');
  
  // swap order w/ the layer above
  var order_above = layer_above.order;
  layer_above.order = layer.order;
  layer.order = order_above;

  sortLayers();
  updateLayerUI();
});

$('layer_down').addEventListener('click', function() {
  var ix = level.layers.indexOf(layer);
  var layer_below = level.layers[ix - 1];
  if (!layer_below)
    throw new Error('layer down enabled, but no layer below');
  
  // swap order w/ the layer below
  var order_below = layer_below.order;
  layer_below.order = layer.order;
  layer.order = order_below;

  sortLayers();
  updateLayerUI();
});

$('delete_layer').addEventListener('click', function() {
  if (level.layers.length == 1)
    throw new Error('Cannot delete last layer');

  var ix = level.layers.indexOf(layer);
  level.layers.splice(ix, 1);
  layer = level.layers[0];
  updateLayerUI();
});

$('toggle_layer').addEventListener('click', function() {
  layer.visible = !layer.visible;
  updateLayerUI();
});

function sortLayers() {
  level.layers.sort((a, b) => a.order - b.order);
}

$('tilesets').addEventListener('change', function(evt) {
  viewSpritesheet(parseInt(evt.target.value));
  updateTilesetUI();
});

$('tileset').addEventListener('mousemove', function(evt) {
  if (!imgs.length)
    return;
  if (tileset_sel)
    return;

  var x = evt.pageX - getClientLeft(evt.target);
  var y = evt.pageY - getClientTop(evt.target);
  var sprite = getSprite(x, y);
  if (sprite != tileset_hover) {
    tileset_hover = sprite;
    updateTilesetUI();
  }
});

$('tileset').addEventListener('mousedown', function(evt) {
  if (!imgs.length)
    return;

  // JIC these old ones are left over (we can't guarantee a mousemove/mouseup will fire)
  if (window.g_tileset_mousemove_handler)
    document.removeEventListener('mousemove', g_tileset_mousemove_handler);
  if (window.g_tileset_mouseup_handler)
    document.removeEventListener('mouseup', g_tileset_mouseup_handler);

  var x = evt.pageX - getClientLeft(evt.target);
  var y = evt.pageY - getClientTop(evt.target);
  var curr_sprite_x = pxToGrid(x);
  var curr_sprite_y = pxToGrid(y);
  
  tileset_sel = {
    start_x: curr_sprite_x,
    start_y: curr_sprite_y,
    end_x: curr_sprite_x,
    end_y: curr_sprite_y
  };
  updateTilesetUI();

  window.g_tileset_mousemove_handler = function(evt) {
    // user is no longer clicking, but somehow 'mouseup' didn't fire (not sure if this ever happens)
    if (evt.buttons % 2 != LEFT_BTN) {
      document.removeEventListener('mousemove', g_tileset_mousemove_handler);
      document.removeEventListener('mouseup', g_tileset_mouseup_handler);
      tileset_sel = null;
      return;
    }

    if (!tileset_sel)
      throw new Error('mousemove somehow fired without a selected object');

    var x = evt.pageX - getClientLeft(evt.target);
    var y = evt.pageY - getClientTop(evt.target);
    tileset_sel.end_x = pxToGrid(x);
    tileset_sel.end_y = pxToGrid(y);
    updateTilesetUI();
  };
  document.addEventListener('mousemove', g_tileset_mousemove_handler);

  window.g_tileset_mouseup_handler = function(evt) {
    document.removeEventListener('mousemove', g_tileset_mousemove_handler);
    document.removeEventListener('mouseup', g_tileset_mouseup_handler);

    if (!tileset_sel)
      throw new Error('mouseup somehow fired without a selected object');
      
    var x = evt.pageX - getClientLeft(evt.target);
    var y = evt.pageY - getClientTop(evt.target);
    tileset_sel.end_x = pxToGrid(x);
    tileset_sel.end_y = pxToGrid(y);

    var sel = tileset_sel;

    // did user click on a single tile? (vs click-and-drag to multiple tiles?)
    // TODO: detect & maintain is_single starting on mousedown, so there isn't a red flash when deselecting
    var is_single = sel.start_x == sel.end_x && sel.start_y == sel.end_y;

    // if user clicked in the selected object, deselect it (toggle)
    if (selected_obj) {
      var obj = {
        x: selected_obj.sprite_x * tile_size,
        y: selected_obj.sprite_y * tile_size,
        w: selected_obj.w,
        h: selected_obj.h
      };
    }
    if (is_single && selected_obj && selected_obj.type == 'sprite' && intersectsPoint(obj, {x: x, y: y})) {
      deselect();
    }
    else {
      // if it's a click on a single tile & there's a sprite there (intersects pt), select that sprite
      if (is_single && getSprite(x, y)) {
        select(getSprite(x, y));
      }
      else {
        var sprite = {
          type: 'sprite',
          id: '',
          sprite_x: sel.start_x < sel.end_x ? sel.start_x : sel.end_x,
          sprite_y: sel.start_y < sel.end_y ? sel.start_y : sel.end_y,
          img_ix: img_ix,

          w: (Math.abs(sel.end_x - sel.start_x) + 1) * tile_size,
          h: (Math.abs(sel.end_y - sel.start_y) + 1) * tile_size,

          components: []
        };

        var coords = getSpriteCoords(sprite);
        var sprites = imgs[img_ix].sprites;

        // only save the new sprite if there isn't already one at the exact coords
        // otherwise just select the preexisting one
        if (!sprites[coords])
          sprites[coords] = sprite;

        select(sprites[coords]);
      }
    }
    tileset_sel = null;
    updateTilesetUI();
  };
  document.addEventListener('mouseup', g_tileset_mouseup_handler);
});

function getSprite(x, y) {
  let sprites = imgs[img_ix].sprites;

  let intersecting_sprites = [];
  for (let coords in sprites) {
    let sprite = sprites[coords];
    let obj = {
      x: sprite.sprite_x * tile_size,
      y: sprite.sprite_y * tile_size,
      w: sprite.w,
      h: sprite.h
    };
    if (intersectsPoint(obj, {x: x, y: y}))
      intersecting_sprites.push(sprite);
  }

  // select the smallest sprite
  // (otherwise you'll never be able to select them b/c they're covered by bigger sprites)
  let sprite;
  for (let s of intersecting_sprites)
    if (sprite == null || (s.w * s.h < sprite.w * sprite.h))
      sprite = s;

  return sprite;
}

function deleteSprite(sprite) {
  var sprites = imgs[img_ix].sprites;
  var coords = getSpriteCoords(sprite);
  delete sprites[coords];
}

function getSpriteCoords(sprite) {
  var first = sprite.sprite_x;
  
  // check if the x coord is a range ("3-5")
  var sprite_w = sprite.w / tile_size;
  if (sprite_w > 1)
    first += '-' + (sprite.sprite_x + sprite_w);

  var second = sprite.sprite_y;

  // check if the y coord is a range ("7-8")
  var sprite_h = sprite.h / tile_size;
  if (sprite_h > 1)
    second += '-' + (sprite.sprite_y + sprite_h);

  return first + ',' + second;
}



function clonePropsFromSprite(obj, sprite) {
  for (var prop in sprite)
    if (prop != 'type' && prop != 'id')
      obj[prop] = sprite[prop];
  
  obj.components = obj.components.slice();
}

function viewSpritesheet(ix) {
  img_ix = ix;
  $('tileset').setAttribute('width', imgs[img_ix].width);
  $('tileset').setAttribute('height', imgs[img_ix].height);
}

function getClientLeft(el) {
  var offset = 0;

  while (el) {
    offset += parseInt(el.offsetLeft);
    offset -= el.scrollLeft;
    el = el.offsetParent;         
  }
  return offset;
}

function getClientTop(el) {
  var offset = 0;

  while (el) {
    offset += parseInt(el.offsetTop);
    offset -= el.scrollTop;
    el = el.offsetParent;         
  }
  return offset;
}

$('add-img').addEventListener('change', function() {
  var file = this.files[0];
  var data_url = URL.createObjectURL(file);
  var img_ix = imgs.length;
  loadImage(img_ix, data_url, file.name);
});

$("update-img").addEventListener("change", function() {
  var file = this.files[0];
  var data_url = URL.createObjectURL(file);
  var img_ix = parseInt($('tilesets').value);
  loadImage(img_ix, data_url, file.name);
});

async function loadImage(img_ix, data_url, filename, sprites) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.filename = filename;
    img.sprites = sprites || {};
    
    img.onload = function() {
      // free the memory (unfortunately this is a blob-url ref, not a full data-url)
      URL.revokeObjectURL(this.src);

      var prev_length = imgs.length;
      imgs[img_ix] = img;
      if (imgs.length > prev_length)
        viewSpritesheet(img_ix);

      // TODO: add an opt-out checkbox in case users are adding lots of images?
      // Or, instead, allow different grid sizes on each spritesheet via num_cols/num_rows text boxes
      var misaligned_dimensions = [];
      if (img.width % tile_size)
        misaligned_dimensions.push(`width (${img.width})`);
      if (img.height % tile_size)
        misaligned_dimensions.push(`height (${img.height})`)
      if (misaligned_dimensions.length)
        alert(`Warning: tileset image ${misaligned_dimensions.join(', ')} does not align with tile size (${tile_size})`);

      num_tiles_w = Math.ceil(img.width / tile_size);
      num_tiles_h = Math.ceil(img.height / tile_size);
      $('tileset').setAttribute('width', img.width);
      $('tileset').setAttribute('height', img.height);
      updateTilesetUI();

      var opts = imgs.map((img, ix) => [img.filename, ix]);
      setSelectOptions('tilesets', opts);
      $('tilesets').value = img_ix;

      $("tilesets").style.display = '';
      $("update-img-label").style.display = '';
      $("update-img").style.display = '';
      $("tileset").style.display = '';
      resolve();
    };

    img.src = data_url;
  });
}

var LEFT = 37;
var UP = 38;
var RIGHT = 39;
var DOWN = 40;
var DEL = 8;
var ESC = 27;
document.addEventListener('keydown', function(evt) {
  if (document.activeElement && (document.activeElement.tagName == 'TEXTAREA' || document.activeElement.tagName == 'INPUT'))
    return;

  if (evt.keyCode == LEFT && player.accel_y != 0)
      player.vel_x = -5;
  else if (evt.keyCode == RIGHT && player.accel_y != 0)
      player.vel_x = 5;
  else if (evt.keyCode == UP && player.accel_x != 0)
    player.vel_y = -5;
  else if (evt.keyCode == DOWN && player.accel_x != 0)
    player.vel_y = 5;
  else if (evt.keyCode == DEL && selected_obj) {
    if (selected_obj.type == 'sprite')
      deleteSprite(selected_obj);
    else
      deleteObject(selected_obj);  

    deselect();
  }
  else if (evt.keyCode == ESC) {
    if (img_editor) {
      img_editor.destroy();
      img_editor = null;
      game_editor = new GameEditor(ctx);
      viewport.follow(player);
    }
    else if (selected_obj) {
      deselect();
    }
  }
});

function save() {
  if (!game_name)
    game_name = prompt('What would you like to name this game?');

  var json = serializeGame();
  localStorage.setItem(game_name, json);
}

function serializeGame() {
  var data = {images: [], levels: levels};
  
  // serialize image pixel data
  for (var i = 0; i < imgs.length; i++) {
    if (imgs[i]) {
      var canvas = document.createElement('canvas');
      canvas.width = imgs[i].width;
      canvas.height = imgs[i].height;
      var context = canvas.getContext('2d');
      context.drawImage(imgs[i], 0, 0);
      data.images[i] = {url: canvas.toDataURL(), filename: imgs[i].filename, sprites: imgs[i].sprites};
    }
    else {
      data.images[i] = null;
    }
  }
  return JSON.stringify(data);
}

function load() {
  if (!game_name)
    game_name = prompt('What game would you like to load?');
  
  if (game_name == null) // user clicked "Cancel" or typed nothing
    return;

  if (game_name == '')
    return alert('No name entered, cancelling load.')

  var json = localStorage.getItem(game_name);
  if (!json)
    return alert('Sorry, no level with the name "' + game_name + '" exists.');

  var parsed = JSON.parse(json);
  loadGame(parsed);
}

function jump() {
  if (player.accel_y > 0)
    player.vel_y = -20;
  else if (player.accel_y < 0)
    player.vel_y = 20;
  if (player.accel_x > 0)
    player.vel_x = -20;
  else if (player.accel_x < 0)
    player.vel_x = 20;
}

// HTML DOM helpers
function toggle_visibility(id_or_el, id2, id3) {
  for (var id_or_el of Array.from(arguments)) {
    if (is_visible(id_or_el))
      hide(id_or_el);
    else
      show(id_or_el);
  }
}
function show(id_or_el, id2, id3) {
  for (var id_or_el of Array.from(arguments))
    $(id_or_el).style.display = '';  
}
function hide(id_or_el, id2, id3) {
  for (var id_or_el of Array.from(arguments))
    $(id_or_el).style.display = 'none';
}
function is_visible(id_or_el) {
  return $(id_or_el).style.display != 'none';
}
function $(id_or_el) {
  if (id_or_el instanceof HTMLElement)
    return id_or_el;
  else
    return document.getElementById(id_or_el);
}
function $$(class_name) {
  return document.getElementsByClassName(class_name);
}

function hasClass(el, class_name) {
  var class_names = el.className.split(' ');
  return class_names.indexOf(class_name) > -1;
}

function addClass(el, class_name) {
  var class_names = el.className.split(' ');
  if (class_names.indexOf(class_name) > -1)
    return;

  class_names.push(class_name);
  el.className = class_names.join(' ');
}

function removeClass(el, class_name) {
  var class_names = el.className.split(' ');
  var ix = class_names.indexOf(class_name);
  if (ix == -1)
    return;

  class_names.splice(ix, 1);
  el.className = class_names.join(' ');
}

function toggleClass(el, class_name, class_name2, class_name3) {
  var args = Array.from(arguments);
  args = args.slice(1); // trim off el
  for (var class_name of args) {
    if (hasClass(el, class_name))
      removeClass(el, class_name);
    else
      addClass(el, class_name);
  }
}

function downloadJSON(json, filename) {
  var uri = "data:application/json;base64," + btoa(json);
  var link = document.createElement("a");
  link.download = filename;
  link.href = uri;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  delete link;
}

function getQueryVariable(variable) {
  var query = window.location.search.substring(1);
  var vars = query.split('&');
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split('=');
    if (decodeURIComponent(pair[0]) == variable)
      return decodeURIComponent(pair[1]);
  }
}

async function loadGame(parsed) {
  levels = parsed.levels;

  var images = parsed.images || [];
  for (var i = 0; i < images.length; i++) {
    if (images[i])
      await loadImage(i, images[i].url, images[i].filename, images[i].sprites);
  }

  loadLevel(1);
}

function play() {
  deselect();
  is_playing = true;
  hideDesignUI();
  startLevel();
}
function hideDesignUI() {
  hide('sidebar', 'load', 'save', 'export', 'coords');
}
function stop() {
  // switch in-game things back to original settings
  setCursor('default');
  setStatus('');

  is_playing = false;
  load();
  showDesignUI();
}
function showDesignUI() {
  show('sidebar', 'load', 'save', 'export', 'coords');
}


function loadLevel(level_n) {
  unloadLevel();

  level_num = level_n;
  level = levels[level_num - 1];
  deselect();
  updateLevelsUI();

  objects = level.objects;
  layer = level.layers[0];
  updateLayerUI();

  player.x = start_x;
  player.y = start_y;
  player.vel_y = 0;
  player.vel_x = 0;
  player.accel_x = 0;
  player.accel_y = 0;
}

function unloadLevel() {
  if (!level)
    return;

  if (level.objects != objects)
    throw new Error('level.objects != objects (due to hacking objects in console?)');

  while (objects.length)
    deleteObject(objects[0]);
}

function startLevel() {
  // update level dimensions
  level.x = null;
  level.y = null;
  var level_bottom = null;
  var level_right = null;

  for (var obj of objects) {
    if (level.x == null || obj.x < level.x)
      level.x = obj.x;
    if (level.y == null || obj.y < level.y)
      level.y = obj.y;

    var obj_bottom = obj.y + obj.h;
    if (level_bottom == null || obj_bottom > level_bottom)
      level_bottom = obj_bottom;
    var obj_right = obj.x + obj.w;
    if (level_right == null || obj_right > level_right)
      level_right = obj_right;
  }
  level.h = level_bottom - level.y;
  level.w = level_right - level.x;
}

function createObject(x, y, sprite, layer_id) {
  if (layer_id == null)
    layer_id = layer.id;

  var obj = {
    // Positionable (w & h are derived from sprite)
    x: x,
    y: y,
    
    // Drawable (the others are derived from sprite)
    layer_id: layer_id,

    // TODO: remove these
    type: 'tile',
    timeout_ids: null
  };

  clonePropsFromSprite(obj, sprite);

  for (let comp_id of required_comp_ids)
    if (!hasComp(obj, comp_id))
      obj.components.push(comp_id);

  // set default properties for components
  for (let component_name in components)
    if (hasComp(obj, component_name))
      for (let prop of components[component_name])
        if (!(prop[ID] in obj))
          obj[prop[ID]] = prop[DEFAULT];

  objects.push(obj);  
  return obj;
}

function deleteObject(obj) {
  var ix = objects.indexOf(obj);
  if (ix > -1)
    objects.splice(ix, 1);
}

function getSpriteByID(sprite_id) {
  for (let img of imgs)
    if (img)
      for (var coords in img.sprites)
        if (img.sprites[coords].id == sprite_id)
          return img.sprites[coords];
}

function setStatus(str) {
  $('status').innerText = str;
}

function setCursor(cursor_id) {
  $('canvas').style.cursor = cursor_id;
}

</script>
</body>
</html>