<!doctype html>
<html>
<head>
<style>
body {
  margin: 0;
  padding: 0;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
}
#header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 30px;
  background-color: #eeeeee;
  border-bottom: 1px solid #cccccc;
  padding: 3px;
}
#cur_color {
  height: 28px;
  width: 36px;
  border: 1px solid #666666;
}

#properties {
  position: absolute;
  z-index: 100;
  top: 37px;
  bottom: 0;
  width: 200px;
  background-color: #eee;
  color: #666;
  padding: 5px;
}
#properties.left {
  left: 0;
}
#properties.right {
  right: 0;
}
#properties.faded {
  opacity: 0.5;
}
#properties td {
  vertical-align: top
}
ul {
  margin: 0;
  padding-left: 20px;
}
textarea {
  width: 195px;
  height: 80px;
}
</style>
</head>
<body>
<canvas id="canvas">
</canvas>
<div id="properties" style="right: 0px">
  API:
  <ul>
    <li>setGravity(x, y)</li>
    <li>setSpeed(x, y)</li>
    <li>setPosition(x, y)</li>
    <li>setStart(x, y)</li>
    <li>restart()</li>
    <li>loadLevel(level_name)</li>
  </ul><br>
  <input type="checkbox" id="is-solid"> Solid <button id="edit-img">Edit Image</button><br>
<textarea id="code"></textarea>
</div>
<div id="header">
  <div id="cur_color"></div>
</div>
<script>
document.body.style.overflow = 'hidden';

var canvas = $('canvas');
var viewport = new Viewport(window.innerWidth || document.body.clientWidth, window.innerHeight|| document.body.clientHeight);
canvas.setAttribute('width', viewport.width);
canvas.setAttribute('height', viewport.height);
var ctx = canvas.getContext('2d');

$('properties').addEventListener('mouseover', function() {
  var prop_panel = $('properties');
  if (hasClass(prop_panel, 'faded')) {
    if (hasClass(prop_panel, 'left')) {
      removeClass(prop_panel, 'left');
      addClass(prop_panel, 'right');
    }
    else {
      removeClass(prop_panel, 'right');
      addClass(prop_panel, 'left');
    }
  }
});

function GameEditor(ctx) {
  this.setColor(current_color_ix || 1);

  this.onMouseMove = this.onMouseMove.bind(this);
  this.onMouseDown = this.onMouseDown.bind(this);
  this.onKeyPress = this.onKeyPress.bind(this);
  canvas.addEventListener('mousemove', this.onMouseMove);
  canvas.addEventListener('mousedown', this.onMouseDown);
  document.addEventListener('keypress', this.onKeyPress);
}

GameEditor.prototype.onMouseDown = function(evt) {
  var pt = {
    x: evt.pageX + viewport.transform_x,
    y: evt.pageY + viewport.transform_y
  };

  var obj_under_mouse;
  for (var i = 0; i < objects.length; i++) {
    var obj = objects[i];
    if (intersectsPoint(obj, pt))
      obj_under_mouse = obj;
  }

  if (obj_under_mouse) {
    if (obj_under_mouse == selected_block)
      deselectBlock();
    else
      selectBlock(obj_under_mouse);
  }
  else {
    createBlock(pt.x, pt.y);
  }
};

var LEFT_BTN = 1;
GameEditor.prototype.onMouseMove = function(evt) {
  if (evt.buttons % 2 != LEFT_BTN)
    return;

  var pt = {
    x: evt.pageX + viewport.transform_x,
    y: evt.pageY + viewport.transform_y
  };
  var obj_under_mouse;
  for (var i = 0; i < objects.length; i++) {
    var obj = objects[i];
    if (intersectsPoint(obj, pt))
      obj_under_mouse = obj;
  }
  
  if (!obj_under_mouse)
    createBlock(pt.x, pt.y);
};

// load & save
GameEditor.prototype.onKeyPress = function(evt) {
  if (document.activeElement && document.activeElement == document.getElementById('code'))
    return;
  
  if (evt.keyCode == 's'.charCodeAt(0))
    save();
  else if (evt.keyCode == 'l'.charCodeAt(0))
    load();
  else if (evt.keyCode == ' '.charCodeAt(0))
    jump();
  else if (evt.keyCode == 'r'.charCodeAt(0))
    restart();
  else if (evt.keyCode == '1'.charCodeAt(0))
    this.setColor(1);
  else if (evt.keyCode == '2'.charCodeAt(0))
    this.setColor(2);
  else if (evt.keyCode == '3'.charCodeAt(0))
    this.setColor(3);
  else if (evt.keyCode == '4'.charCodeAt(0))
    this.setColor(4);
  else if (evt.keyCode == '5'.charCodeAt(0))
    this.setColor(5);
  else if (evt.keyCode == '6'.charCodeAt(0))
    this.setColor(6);
  else if (evt.keyCode == '7'.charCodeAt(0))
    this.setColor(7);
  else if (evt.keyCode == '8'.charCodeAt(0))
    this.setColor(8);
  else if (evt.keyCode == '9'.charCodeAt(0))
    this.setColor(9);
};

GameEditor.prototype.setColor = function(color_ix) {
  current_color_ix = color_ix;
  document.getElementById('cur_color').style.backgroundColor = colors[color_ix];
  if (selected_block) {
    selected_block.type = current_color_ix;
    updateProperties(selected_block);
  }
};

GameEditor.prototype.destroy = function() {
  canvas.removeEventListener('mousedown', this.onMouseDown);
  canvas.removeEventListener('mousemove', this.onMouseMove);
  document.removeEventListener('keypress', this.onKeyPress);
};

var MAX_VEL = 100;

var grid_width = 100;
var grid_height = 100;
var objects = [];
var block_size = 40;
var selected_block = null;
var current_color_ix = 1;
var img_editor = null;
var start_x = 0;
var start_y = 0;
var imgs = [];

// i thought these colors were taken from a DB16 palette
// but they weren't, they're from another "DawnBringer" palette here:
// http://pixeljoint.com/forum/forum_posts.asp?TID=22582
var colors = [
  null, // at present 1-9 are the colors, 0 means no-block & isn't a color
  '#5e6660', // dark-ish grey
  '#5d4632', // dark brown
  '#44508c', // med (darker) blue
  '#a6414d', // dark red
  '#c86b36', // orange
  '#52903c', // dark green
  '#db7ebd', // pink
  '#deac85', // tan
  '#f2de70' // yellow
];

var player = {x: 0, y: 0, vel_x: 0, vel_y: 0, accel_y: 1};
createBlock(0, 8 * block_size);

var game_editor = new GameEditor(ctx);

function createBlock(x, y) {
  x = Math.floor(x / block_size) * block_size;
  y = Math.floor(y / block_size) * block_size;
  var obj = {
    x: x,
    y: y,
    w: block_size,
    h: block_size,
    type: current_color_ix,
    is_solid: true
  };

  objects.push(obj);
  selectBlock(obj);
}

function selectBlock(obj) {
  selected_block = obj;
  updateProperties(obj);
  removeClass($('properties'), 'faded');
}

function deselectBlock() {
  selected_block = null;
  addClass($('properties'), 'faded');
}

function updateProperties(obj) {
  document.getElementById('is-solid').checked = obj.is_solid;
  document.getElementById('code').value = obj.code || '';
  document.getElementById('edit-img').textContent = 'Edit Image ' + obj.type;
}

requestAnimationFrame(draw);
function draw() {
  ctx.clearRect(viewport.transform_x, viewport.transform_y, viewport.width, viewport.height);
  
  if (img_editor) {
    img_editor.draw();
  }
  else {
    update();

    // draw blocks on the grid
    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];
      if (imgs[obj.type]) {
        // the transformation matrix doesn't affect putImageData()
        // so we have to transform manually
        ctx.putImageData(imgs[obj.type], obj.x - viewport.transform_x, obj.y - viewport.transform_y);
      }
      else {
        ctx.fillStyle = colors[obj.type];
        ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
      }
    }

    // draw selection
    if (selected_block) {
      ctx.strokeStyle = '#6666FF';
      ctx.lineWidth=5;
      ctx.strokeRect(selected_block.x, selected_block.y, selected_block.w, selected_block.h);
    }

    // draw player
    ctx.beginPath();
    var radius = block_size / 2;
    ctx.arc(Math.floor(player.x) + radius, Math.floor(player.y) + radius, radius, 0, 2 * Math.PI, false);
    ctx.fillStyle = '#5b99f4';
    ctx.fill();
  }
  requestAnimationFrame(draw);
}

function update() {
  // friction/drag
  if (player.vel_x > 0)
    player.vel_x -= 0.1;
  else if (player.vel_y < 0)
    player.vel_x += 0.1;
  if (player.vel_y > 0)
    player.vel_y -= 0.1;
  else if (player.vel_y < 0)
    player.vel_y += 0.1;

  // y-axis acceleration (gravity) & x-axis acceleration (sideways gravity)
  if (player.accel_y)
    player.vel_y += player.accel_y;
  if (player.accel_x)
    player.vel_x += player.accel_x;

  // TODO: use a clamp() function
  if (player.vel_x > MAX_VEL)
    player.vel_x = MAX_VEL;
  else if (player.vel_x < -MAX_VEL)
    player.vel_x = -MAX_VEL;
  if (player.vel_y > MAX_VEL)
    player.vel_y = MAX_VEL;
  else if (player.vel_y < -MAX_VEL)
    player.vel_y = -MAX_VEL;

  player.x = player.x + player.vel_x;
  player.y = player.y + player.vel_y;

  // super-simple AABB collision detection & "slide" resolution
  for (var i = 0; i < objects.length; i++) {
    var obj = objects[i];
    var intersection = getIntersection(
      {x1: player.x, x2: player.x + block_size, y1: player.y, y2: player.y + block_size},
      {x1: obj.x, x2: obj.x + obj.w, y1: obj.y, y2: obj.y + obj.h}
    );
    if (intersection) {
      if (obj.is_solid) {
        var x_overlap = intersection.x2 - intersection.x1;
        var y_overlap = intersection.y2 - intersection.y1;
        if (x_overlap < y_overlap) {
          // back out the x overlap
          var player_on_left = player.x < obj.x;
          if (player_on_left)
            player.x -= x_overlap;
          else
            player.x += x_overlap;
          player.vel_x = 0;
        }
        else {
          // back out the y overlap
          var player_above = player.y < obj.y;
          if (player_above)
            player.y -= y_overlap;
          else
            player.y += y_overlap;

          // drop the y velocity to zero on a vertical collision
          // w/out this, the constant collisions caused by gravity
          // cause some side-effects
          // but sometimes it's not perfect, like when hitting a corner
          // dropping the `vel_x` to zero makes the sideways velocity drop to zero sometimes
          // when dropping to the ground
          player.vel_y = 0;
        }
      }
      onCollide(obj);
    }
  }

  if (player.vel_x || player.vel_y)
    viewport.follow(player);
}

function onCollide(obj) {
  if (obj.code) {
    try {
      eval(obj.code);
    }
    catch(err) {
      alert(err.message);
      var lines = obj.code.split('\n');
      for (var i = 0; i < lines.length; i++)
        lines[i] = '// ' + lines[i];

      obj.code = lines.join('\n');
      if (selected_block && selected_block == obj)
        updateProperties(obj);
    }
  }
}

function intersectsPoint(rect, pt) {
  return rect.x < pt.x && rect.x + rect.w > pt.x &&
    rect.y < pt.y && rect.y + rect.h > pt.y;
}

function getIntersection(rect1, rect2) {
  if (rect1.x1 > rect1.x2 || rect1.y1 > rect1.y2)
    throw new Error('rect1 is degenerate');
  if (rect2.x1 > rect2.x2 || rect2.y1 > rect2.y2)
    throw new Error('rect2 is degenerate');

  var x1 = Math.max(rect1.x1, rect2.x1); // biggest left edge
  var x2 = Math.min(rect1.x2, rect2.x2); // smallest right edge

  var y1 = Math.max(rect1.y1, rect2.y1); // lowest top edge
  var y2 = Math.min(rect1.y2, rect2.y2); // highest bottom edge

  if (x1 >= x2 // if the biggest left edge is bigger than the smallest right edge
    || y1 >= y2) // or the lowest top edge is lower than the highest bottom edge
    return null; // then they don't actually intersect
  
  return {x1: x1, y1: y1, x2: x2, y2: y2};
}

document.getElementById('code').addEventListener('keypress', function(evt) {
  var block = selected_block;
  setTimeout(function() {
    if (block)
      block.code = evt.target.value;
  }, 0);
});

document.getElementById('is-solid').addEventListener('change', function(evt) {
  if (selected_block)
    selected_block.is_solid = !!evt.target.checked;
});

document.getElementById('edit-img').addEventListener('click', function() {
  if (selected_block)
    edit(selected_block.type);
});

var LEFT = 37;
var UP = 38;
var RIGHT = 39;
var DOWN = 40;
var DEL = 8;
var ESC = 27;
document.addEventListener('keydown', function(evt) {
  if (document.activeElement && document.activeElement == document.getElementById('code'))
    return;

  if (evt.keyCode == LEFT && player.accel_y != 0)
      player.vel_x = -5;
  else if (evt.keyCode == RIGHT && player.accel_y != 0)
      player.vel_x = 5;
  else if (evt.keyCode == UP && player.accel_x != 0)
    player.vel_y = -5;
  else if (evt.keyCode == DOWN && player.accel_x != 0)
    player.vel_y = 5;
  else if (evt.keyCode == DEL && selected_block) {
    var ix = objects.indexOf(selected_block);
    if (ix > -1)
      objects.splice(ix, 1);
    deselectBlock();
  }
  else if (evt.keyCode == ESC) {
    if (img_editor) {
      img_editor.destroy();
      img_editor = null;
      game_editor = new GameEditor(ctx);
      viewport.follow(player);
    }
    else if (selected_block) {
      deselectBlock();
    }
  }
});

function edit(img_ix) {
  if (!img_editor) {
    deselectBlock();
    img_editor = new ImageEditor(ctx, img_ix);
    game_editor.destroy();
  }
}

function save() {
  var name = prompt('What would you like to name this level?');
  var data = {objects: objects, images: []};
  
  // serialize image pixel data
  for (var i = 0; i < imgs.length; i++) {
    if (imgs[i]) {
      data.images[i] = [];
      for (var j = 0; j < imgs[i].data.length; j++)
        data.images[i][j] = imgs[i].data[j];
    }
    else {
      data.images[i] = null;
    }
  }
  localStorage.setItem(name, JSON.stringify(data));
}

function load() {
  var name = prompt('What level would you like to load?');
  loadLevel(name);
}

function jump() {
  if (player.accel_y > 0)
    player.vel_y = -20;
  else if (player.accel_y < 0)
    player.vel_y = 20;
  if (player.accel_x > 0)
    player.vel_x = -20;
  else if (player.accel_x < 0)
    player.vel_x = 20;
}

function Viewport(width, height) {
  this.width = width;
  this.height = height;
  this.transform_x = 0;
  this.transform_y = 0;
}

Viewport.prototype.follow = function(pos) {
  var perct_x = (pos.x - this.transform_x) / this.width;
  var perct_y = (pos.y - this.transform_y) / this.height;

  if (perct_x > .8) {
    var dest_x = Math.round(this.width * .8);
    this.transform_x = pos.x - dest_x;
  }
  else if (perct_x < .2) {
    var dest_x = Math.round(this.width * .2);
    this.transform_x = pos.x - dest_x; 
  }
  if (perct_y > .8) {
    var dest_y = Math.round(this.height * .8);
    this.transform_y = pos.y - dest_y;
  }
  else if (perct_y < .2) {
    var dest_y = Math.round(this.height * .2);
    this.transform_y = pos.y - dest_y;
  }
  ctx.setTransform(1, 0, 0, 1, -this.transform_x, -this.transform_y);
};

// DOM helpers
function $(id) {
  return document.getElementById(id);
}

function hasClass(el, class_name) {
  var class_names = el.className.split(' ');
  return class_names.indexOf(class_name) > -1;
}

function addClass(el, class_name) {
  var class_names = el.className.split(' ');
  if (class_names.indexOf(class_name) > -1)
    return;

  class_names.push(class_name);
  el.className = class_names.join(' ');
}

function removeClass(el, class_name) {
  var class_names = el.className.split(' ');
  var ix = class_names.indexOf(class_name);
  if (ix == -1)
    return;

  class_names.splice(ix, 1);
  el.className = class_names.join(' ');
}

function ImageEditor(ctx, img_ix) {
  this.color_ix = 0;
  this.img_ix = img_ix;
  this.px_size = 15;
  this.y = 50;
  this.x = 5;
  this.is_drawing = false;
  this.is_erasing = false;
  if (!imgs[img_ix]) {
    imgs[img_ix] = ctx.createImageData(block_size, block_size);

    // pre-fill new images to all-white
    var data = imgs[img_ix].data;
    for (var i = 0; i < data.length; i++)
      data[i] = 255;
  }
  this.img_data = imgs[img_ix];
  this.ctx = ctx;

  // reset the transform from the game's viewport
  this.ctx.setTransform(1, 0, 0, 1, 0, 0);

  this.updateColorIndicator();

  this.onKeyPress = this.onKeyPress.bind(this);
  this.onMouseDown = this.onMouseDown.bind(this);
  this.onMouseMove = this.onMouseMove.bind(this);
  document.addEventListener('keypress', this.onKeyPress);
  document.addEventListener('mousemove', this.onMouseMove);
  document.addEventListener('mousedown', this.onMouseDown);
};

// official DawnBringer16 palette
ImageEditor.rgb = [
  [20, 12, 28], // #140C1C Black
  [68, 36, 52], // #442434 Dark Red
  [48, 52, 109], // #30346D Dark Blue
  [78, 74, 78], // #4E4A4F Dark Gray
  [133, 76, 48], // #854C30 Brown
  [52, 101, 36], // #346524 Dark Green
  [208, 70, 72], // #D04648 Red
  [117, 113, 97], // #757161 Light Gray
  [89, 125, 206], // #597DCE Light Blue
  [210, 125, 44], // #D27D2C Orange
  [133, 149, 161], // #8595A1 Blue/Gray
  [109, 170, 44], // #6DAA2C Light Green
  [210, 170, 153], // #D2AA99 Peach
  [109, 194, 202], // #6DC2CA Cyan
  [218, 212, 94], // #DAD45E Yellow
  [222, 238, 214] // #DEEED6 White
];

ImageEditor.prototype.onMouseDown = function(evt) {
  var x = Math.floor((evt.pageX - this.x) / this.px_size);
  var y = Math.floor((evt.pageY - this.y) / this.px_size);

  // user clicked outside the image size
  if (x < 0 || x >= block_size || y < 0 || y >= block_size)
    return;

  if (this.isPixel(x, y, this.color_ix)) {
    this.is_erasing = true;
    this.is_drawing = false;
  }
  else {
    this.is_erasing = false;
    this.is_drawing = true;
  }

  if (this.is_erasing)
    this.clearPixel(x, y);
  else if (this.is_drawing)
    this.setPixel(x, y, this.color_ix);
};

ImageEditor.prototype.onMouseMove = function(evt) {
  if (evt.buttons %2 != LEFT_BTN)
    return;

  var x = Math.floor((evt.pageX - this.x) / this.px_size);
  var y = Math.floor((evt.pageY - this.y) / this.px_size);

  // user is dragging outside the image size
  if (x < 0 || x >= block_size || y < 0 || y >= block_size)
    return;

  if (this.is_erasing)
    this.clearPixel(x, y);
  else if (this.is_drawing)
    this.setPixel(x, y, this.color_ix);
};

ImageEditor.prototype.setPixel = function(x, y, color_ix) {
  var ix = this.coordsToIx(this.img_data.width, x, y);
  var rgb = ImageEditor.rgb[color_ix];
  var data = this.img_data.data;
  data[ix] = rgb[0];
  data[ix+1] = rgb[1];
  data[ix+2] = rgb[2];
  data[ix+3] = 255; // alpha channel
};

ImageEditor.prototype.isPixel = function(x, y, color_ix) {
  var ix = this.coordsToIx(this.img_data.width, x, y);
  var data = this.img_data.data;
  var rgb = ImageEditor.rgb[color_ix];
  return data[ix] == rgb[0] || data[ix+1] == rgb[1] || data[ix+2] == rgb[2]
};

ImageEditor.prototype.clearPixel = function(x, y) {
  var ix = this.coordsToIx(this.img_data.width, x, y);
  var data = this.img_data.data;
  data[ix] = 255;
  data[ix+1] = 255;
  data[ix+2] = 255;
  data[ix+3] = 255; // alpha channel
};

ImageEditor.prototype.onKeyPress = function(evt) {
  if (evt.keyCode == '0'.charCodeAt(0))
    this.setColor(0);
  else if (evt.keyCode == '1'.charCodeAt(0))
    this.setColor(1);
  else if (evt.keyCode == '2'.charCodeAt(0))
    this.setColor(2);
  else if (evt.keyCode == '3'.charCodeAt(0))
    this.setColor(3);
  else if (evt.keyCode == '4'.charCodeAt(0))
    this.setColor(4);
  else if (evt.keyCode == '5'.charCodeAt(0))
    this.setColor(5);
  else if (evt.keyCode == '6'.charCodeAt(0))
    this.setColor(6);
  else if (evt.keyCode == '7'.charCodeAt(0))
    this.setColor(7);
  else if (evt.keyCode == '8'.charCodeAt(0))
    this.setColor(8);
  else if (evt.keyCode == '9'.charCodeAt(0))
    this.setColor(9);
  else if (evt.keyCode == 'f'.charCodeAt(0))
    this.fill(this.color_ix);
};

ImageEditor.prototype.setColor = function(color_ix) {
  this.color_ix = color_ix;
  this.updateColorIndicator();
};

ImageEditor.prototype.updateColorIndicator = function() {
  var rgb = ImageEditor.rgb[this.color_ix];
  document.getElementById('cur_color').style.backgroundColor = 'rgb(' + rgb[0] + ', ' + rgb[1] + ', ' + rgb[2] + ')';
};

ImageEditor.prototype.fill = function(color_ix) {
  for (var x = 0; x < block_size; x++)
    for (var y = 0; y < block_size; y++)
      this.setPixel(x, y, color_ix);
};

ImageEditor.prototype.draw = function() {
  var img_w = this.img_data.width;
  var data = this.img_data.data;
  for (var i = 0; i < data.length; i = i + 4) {
    this.ctx.fillStyle = 'rgb(' + data[i] + ', ' + data[i+1] + ', ' + data[i+2] + ')';
    var coords = this.ixToCoords(img_w, i);
    this.ctx.fillRect(coords.x * this.px_size + this.x, coords.y * this.px_size + this.y, this.px_size, this.px_size);
  }

  this.ctx.strokeStyle = '#000000';
  this.ctx.lineWidth = 1;
  this.ctx.strokeRect(1 + this.x, 1 + this.y, this.px_size * block_size, this.px_size * block_size);
  this.ctx.lineWidth = 0;
};

ImageEditor.prototype.ixToCoords = function(img_w, i) {
  i = i / 4;
  x = i % img_w;
  y = (i - x) / img_w;
  return {x: x, y: y};
};

ImageEditor.prototype.coordsToIx = function(img_w, x, y) {
  return (x + y * img_w) * 4;
};

ImageEditor.prototype.destroy = function() {
  document.removeEventListener('keypress', this.onKeyPress);
  document.removeEventListener('mousedown', this.onMouseDown);
  document.removeEventListener('mousemove', this.onMouseMove);
};

// public API functions (available to the game designer)
function setGravity(x, y) {
  if (x != null)
    player.accel_x = x;
  if (y != null)
  player.accel_y = y;
}

function setSpeed(x, y) {
  if (x != null)
    player.vel_x = x;
  if (y != null)
    player.vel_y = y;
}

function setPosition(x, y) {
  if (x != null)
    player.x = x * block_size;
  if (y != null)
    player.y = y * block_size;
}

function setStart(x, y) {
  if (x != null)
    start_x = x * block_size;
  if (y != null)
    start_y = y * block_size;
}

function restart() {
  player.x = start_x;
  player.y = start_y;
  player.vel_y = 0;
  player.vel_x = 0;
  player.accel_x = 0;
  player.accel_y = 1;
}

function loadLevel(level_name) {
  var json = localStorage.getItem(level_name);
  if (!json)
    return alert('Sorry, no level with the name "' + level_name + '" exists.');
  var parsed = JSON.parse(json);
  objects = parsed.objects;
  var images = parsed.images || [];
  for (var i = 0; i < 10; i++) {
    if (images[i]) {
      imgs[i] = ctx.createImageData(block_size, block_size);
      for (var j = 0; j < images[i].length; j++)
        imgs[i].data[j] = images[i][j];
    }
    else {
      imgs[i] = null;
    }
  }

  restart();
}

</script>
</body>
</html>