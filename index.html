<!doctype html>
<html>
<head>
<style>
body { margin: 0; padding: 0; }
</style>
</head>
<body>
<canvas id="canvas">
</canvas>
<script>
document.body.style.overflow = 'hidden';
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
canvas.setAttribute('width', window.innerWidth || document.body.clientWidth);
canvas.setAttribute('height', window.innerHeight || document.body.clientHeight);

var grid_width = 100;
var grid_height = 100;
var grid = [];
var block_size = 40;

var player = {x: 0, y: 0, vel_x: 0, vel_y: 0};

// initialize grid with 0 objects
for (var x = 0; x < grid_width; x++) {
  grid[x] = [];
  for (var y = 0; y < grid_height; y++)
    grid[x][y] = 0;
}

canvas.addEventListener('mouseup', function(evt) {
  var pos = posFromEvt(evt);
  if (!grid[pos.x][pos.y])
    grid[pos.x][pos.y] = 1;
  else
    grid[pos.x][pos.y] = 0;
});

function posFromEvt(evt) {
  var pos = {x: evt.pageX, y: evt.pageY};
  return toBlockCoords(pos);
}

function toBlockCoords(pos) {
  return {x: Math.floor(pos.x / block_size), y: Math.floor(pos.y / block_size)};
}

requestAnimationFrame(draw);
function draw() {
  ctx.clearRect(0, 0, grid_width * block_size, grid_height * block_size);
  
  update();

  // draw blocks on the grid
  for (var x = 0; x < grid_width; x++) {
    for (var y = 0; y < grid_height; y++) {
      if (grid[x][y] == 0)
        ctx.fillStyle="#FFFFFF";
      else
        ctx.fillStyle = '#666666';
      ctx.fillRect(x * block_size, y * block_size, x * block_size + block_size, y * block_size + block_size);
    }
  }

  // draw player
  ctx.beginPath();
  var radius = block_size / 2;
  ctx.arc(Math.floor(player.x) + radius, Math.floor(player.y) + radius, radius, 0, 2 * Math.PI, false);
  ctx.fillStyle = '#000099';
  ctx.fill();
  requestAnimationFrame(draw);
}

function update() {
  // friction/drag
  if (player.vel_x > 0)
    player.vel_x -= 0.1;
  else if (player.vel_y < 0)
    player.vel_x += 0.1;
  if (player.vel_y > 0)
    player.vel_y -= 0.1;
  else if (player.vel_y < 0)
    player.vel_y += 0.1;

  player.x += player.vel_x;
  player.y += player.vel_y;

  // super-simple collision detection & resolution
  for (var x = 0; x < grid_width; x++) {
    for (var y = 0; y < grid_height; y++) {
      if (grid[x][y] && overlap(player, {x: x * block_size, y: y * block_size})) {
        // back off the velocity one pixel at a time until it's not overlapping
        var backoff_x = 0;
        if (player.vel_x > 0)
          backoff_x = -1;
        else if (player.vel_x < 0)
          backoff_x = 1;

        var backoff_y = 0;
        if (player.vel_y > 0)
          backoff_y = -1;
        else if (player.vel_y < 0)
          backoff_y = 1;

        while (overlap(player, {x: x * block_size, y: y * block_size})) {
          player.x += backoff_x;
          player.y += backoff_y;
        }
      }
    }
  }
}

// load & save
document.addEventListener('keypress', function(evt) {
  if (evt.keyCode == 's'.charCodeAt(0))
    save();
  else if (evt.keyCode == 'l'.charCodeAt(0))
    load();
});

var LEFT = 37;
var UP = 38;
var RIGHT = 39;
var DOWN = 40;
var MAX_VEL = 10;
document.addEventListener('keydown', function(evt) {
  if (evt.keyCode == LEFT)
    player.vel_x = -5;
  else if (evt.keyCode == RIGHT)
    player.vel_x = 5;
  else if (evt.keyCode == UP)
    player.vel_y = -5;
  else if (evt.keyCode == DOWN)
    player.vel_y = 5;

  if (player.vel_x > MAX_VEL)
    player.vel_x = MAX_VEL;
  else if (player.vel_x < -MAX_VEL)
    player.vel_x = -MAX_VEL;
  if (player.vel_y > MAX_VEL)
    player.vel_y = MAX_VEL;
  else if (player.vel_y < -MAX_VEL)
    player.vel_y = -MAX_VEL;
});

function save() {
  var name = prompt('What would you like to name this level?');
  localStorage.setItem(name, JSON.stringify({grid: grid}));
}

function load() {
  var name = prompt('What level would you like to load?');
  var json = localStorage.getItem(name);
  if (!json)
    return alert('Sorry, no level with that name exists.');
  grid = JSON.parse(json).grid;
}

// AABB collision detection from http://gamedev.stackexchange.com/a/913, assumes neither rect is rotated
function overlap(a, b) {
  return !(b.x > (a.x + block_size)
        || (b.x + block_size) < a.x
        || b.y > (a.y + block_size)
        || (b.y + block_size) < a.y);
}

</script>
</body>
</html>